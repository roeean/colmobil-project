<?php


namespace MoRESTAPI;

if (!function_exists("\143\162\171\160\x74\137\162\141\x6e\144\157\155\137\163\x74\162\x69\156\x67")) {
    include_once "\x52\x61\156\144\x6f\155\x2e\160\x68\x70";
}
if (class_exists("\103\162\x79\160\x74\x5f\x48\141\163\150")) {
    goto zm;
}
include_once "\x48\x61\163\150\x2e\x70\150\160";
zm:
if (defined("\x43\x52\x59\120\x54\x5f\122\123\x41\x5f\105\116\x43\x52\131\120\124\x49\117\x4e\137\x4f\101\105\x50")) {
    goto pU;
}
define("\x43\x52\x59\x50\124\x5f\122\123\101\x5f\x45\116\x43\122\131\120\124\111\117\x4e\137\x4f\x41\x45\x50", 1);
pU:
if (defined("\x43\122\x59\120\124\x5f\122\x53\x41\x5f\x45\116\x43\x52\x59\x50\124\x49\117\116\x5f\x50\113\103\x53\61")) {
    goto n4;
}
define("\103\x52\x59\120\124\x5f\x52\x53\101\137\x45\116\103\x52\131\120\x54\111\117\116\x5f\x50\x4b\103\123\x31", 2);
n4:
if (defined("\x43\x52\x59\x50\x54\137\122\x53\101\137\x45\116\x43\x52\x59\x50\x54\111\117\x4e\137\x4e\x4f\116\x45")) {
    goto EG;
}
define("\103\x52\x59\120\124\137\x52\x53\101\137\105\x4e\x43\122\x59\120\124\111\117\x4e\x5f\116\x4f\116\x45", 3);
EG:
if (defined("\x43\122\131\x50\x54\137\122\x53\101\x5f\123\111\107\116\101\124\125\x52\x45\x5f\x50\123\123")) {
    goto Jc;
}
define("\103\x52\131\120\124\137\x52\x53\x41\x5f\x53\111\x47\116\x41\124\x55\122\105\137\120\x53\x53", 1);
Jc:
if (defined("\x43\x52\131\120\x54\137\122\123\x41\x5f\123\111\107\116\101\x54\125\122\x45\x5f\x50\113\x43\123\x31")) {
    goto xQ;
}
define("\103\122\x59\x50\124\x5f\122\x53\101\137\x53\x49\x47\116\101\x54\x55\122\x45\137\120\x4b\103\123\61", 2);
xQ:
if (defined("\x43\122\131\120\124\x5f\122\123\x41\137\x41\x53\x4e\61\x5f\x49\x4e\x54\105\107\105\x52")) {
    goto gZ;
}
define("\x43\x52\131\120\124\137\122\x53\x41\137\101\x53\x4e\x31\137\x49\x4e\124\105\107\x45\x52", 2);
gZ:
if (defined("\x43\122\131\x50\124\x5f\x52\x53\x41\x5f\101\123\116\x31\x5f\x42\x49\x54\x53\x54\x52\111\116\107")) {
    goto UH;
}
define("\x43\x52\131\120\x54\137\x52\123\x41\137\x41\123\116\x31\x5f\102\111\124\123\124\x52\x49\116\107", 3);
UH:
if (defined("\103\x52\x59\120\x54\x5f\122\x53\x41\x5f\101\x53\116\x31\x5f\x4f\x43\124\105\124\123\124\122\111\116\107")) {
    goto Cv;
}
define("\x43\x52\x59\x50\124\x5f\122\123\x41\x5f\x41\123\116\61\137\117\103\x54\x45\x54\x53\124\x52\x49\116\x47", 4);
Cv:
if (defined("\x43\122\131\x50\x54\137\x52\123\101\137\101\123\116\61\x5f\117\x42\x4a\105\x43\x54")) {
    goto gI;
}
define("\103\x52\131\120\x54\x5f\x52\123\x41\137\101\x53\116\61\x5f\x4f\102\112\x45\x43\124", 6);
gI:
if (defined("\x43\x52\x59\120\124\137\x52\x53\x41\x5f\x41\123\116\61\x5f\123\105\121\125\105\116\103\x45")) {
    goto Nd;
}
define("\x43\122\131\120\x54\137\x52\123\x41\137\x41\123\116\61\137\123\x45\x51\125\105\116\103\x45", 48);
Nd:
if (defined("\103\x52\x59\120\x54\137\x52\x53\101\x5f\115\x4f\x44\105\x5f\x49\x4e\124\105\x52\x4e\x41\x4c")) {
    goto hR;
}
define("\103\122\131\x50\124\x5f\x52\x53\101\x5f\x4d\117\x44\x45\137\111\116\124\105\122\116\x41\x4c", 1);
hR:
if (defined("\x43\122\131\120\124\137\x52\x53\101\137\x4d\117\104\x45\137\x4f\x50\x45\116\x53\123\114")) {
    goto Mk;
}
define("\x43\122\131\120\124\137\122\x53\x41\x5f\x4d\117\x44\105\x5f\x4f\120\x45\x4e\123\x53\114", 2);
Mk:
if (defined("\103\122\131\x50\x54\x5f\122\x53\101\x5f\x4f\x50\105\x4e\123\x53\114\x5f\103\117\116\x46\111\107")) {
    goto bX;
}
define("\x43\x52\x59\120\x54\137\122\x53\101\137\x4f\x50\105\x4e\x53\123\x4c\x5f\x43\x4f\x4e\x46\111\x47", dirname(__FILE__) . "\57\x2e\56\57\157\160\x65\x6e\163\163\154\x2e\143\156\146");
bX:
if (defined("\103\122\x59\x50\x54\x5f\x52\x53\101\137\x50\122\x49\126\x41\x54\105\x5f\106\117\122\115\101\x54\137\120\113\103\x53\x31")) {
    goto Fy;
}
define("\103\122\x59\x50\124\137\122\x53\101\x5f\x50\122\111\x56\101\124\x45\137\x46\117\x52\115\x41\124\x5f\x50\113\103\123\61", 0);
Fy:
if (defined("\103\x52\x59\120\124\x5f\x52\123\101\137\x50\122\111\x56\x41\124\105\137\106\x4f\122\115\101\124\137\120\125\x54\124\x59")) {
    goto Hs;
}
define("\103\122\131\120\124\137\x52\123\x41\x5f\x50\x52\x49\x56\x41\124\x45\x5f\x46\117\x52\115\x41\x54\137\x50\125\124\x54\131", 1);
Hs:
if (defined("\103\122\x59\120\x54\137\122\x53\101\x5f\x50\x52\x49\126\101\124\105\137\x46\x4f\x52\115\101\x54\137\x58\115\x4c")) {
    goto ls;
}
define("\103\122\x59\x50\124\x5f\x52\123\x41\x5f\x50\x52\x49\126\101\x54\x45\x5f\106\117\x52\x4d\x41\124\137\130\115\x4c", 2);
ls:
if (defined("\x43\x52\x59\x50\x54\137\122\123\101\137\x50\122\x49\x56\101\124\x45\137\x46\x4f\x52\x4d\x41\124\x5f\x50\x4b\x43\x53\x38")) {
    goto CH;
}
define("\103\122\x59\120\124\137\x52\123\101\x5f\120\122\x49\x56\101\124\105\137\106\117\x52\x4d\101\x54\x5f\120\x4b\x43\123\70", 8);
CH:
if (defined("\x43\122\131\x50\124\x5f\122\123\101\x5f\120\x55\x42\114\x49\x43\137\106\x4f\122\x4d\x41\124\137\x52\101\x57")) {
    goto zy;
}
define("\103\122\x59\120\x54\137\x52\x53\x41\137\120\125\x42\x4c\x49\x43\x5f\x46\117\122\115\101\x54\x5f\x52\x41\127", 3);
zy:
if (defined("\x43\122\x59\x50\124\137\122\x53\x41\137\120\125\x42\x4c\x49\103\x5f\x46\117\122\115\101\x54\x5f\x50\x4b\x43\123\x31")) {
    goto QJ;
}
define("\103\x52\131\120\124\x5f\x52\123\101\137\120\125\102\x4c\x49\103\137\x46\117\x52\x4d\x41\x54\x5f\x50\113\103\123\61", 4);
QJ:
if (defined("\x43\122\x59\x50\x54\x5f\x52\123\x41\137\x50\x55\x42\x4c\111\103\137\106\117\x52\x4d\101\x54\x5f\x50\113\x43\x53\61\x5f\x52\101\x57")) {
    goto XM;
}
define("\103\122\x59\120\124\x5f\x52\x53\x41\137\x50\125\102\114\111\x43\137\106\x4f\122\x4d\101\124\x5f\x50\113\103\x53\x31\137\x52\101\x57", 4);
XM:
if (defined("\x43\122\x59\x50\x54\x5f\x52\123\x41\137\x50\x55\x42\x4c\x49\103\x5f\106\117\122\x4d\101\x54\137\x58\x4d\x4c")) {
    goto CE;
}
define("\x43\x52\x59\x50\124\x5f\x52\x53\x41\x5f\120\x55\102\114\111\103\x5f\106\117\x52\115\x41\x54\137\x58\x4d\x4c", 5);
CE:
if (defined("\x43\x52\131\120\124\137\x52\x53\101\137\120\125\102\x4c\x49\103\x5f\x46\x4f\122\115\x41\x54\x5f\117\120\105\116\123\123\x48")) {
    goto YR;
}
define("\103\122\131\120\x54\137\x52\123\x41\x5f\120\125\102\x4c\111\103\x5f\x46\x4f\122\115\x41\x54\x5f\x4f\120\x45\116\x53\123\x48", 6);
YR:
if (defined("\103\x52\131\120\x54\137\x52\x53\x41\137\x50\125\102\114\111\x43\137\x46\x4f\x52\115\101\124\137\x50\x4b\x43\x53\x38")) {
    goto cc;
}
define("\x43\x52\x59\120\x54\137\x52\x53\x41\x5f\x50\125\x42\x4c\111\x43\x5f\x46\x4f\x52\115\x41\x54\137\120\x4b\x43\x53\x38", 7);
cc:
class Crypt_RSA
{
    var $zero;
    var $one;
    var $privateKeyFormat = CRYPT_RSA_PRIVATE_FORMAT_PKCS1;
    var $publicKeyFormat = CRYPT_RSA_PUBLIC_FORMAT_PKCS8;
    var $modulus;
    var $k;
    var $exponent;
    var $primes;
    var $exponents;
    var $coefficients;
    var $hashName;
    var $hash;
    var $hLen;
    var $sLen;
    var $mgfHash;
    var $mgfHLen;
    var $encryptionMode = CRYPT_RSA_ENCRYPTION_OAEP;
    var $signatureMode = CRYPT_RSA_SIGNATURE_PSS;
    var $publicExponent = false;
    var $password = false;
    var $components = array();
    var $current;
    var $configFile;
    var $comment = "\x70\x68\160\163\145\143\154\x69\x62\x2d\x67\x65\156\145\x72\x61\x74\145\144\55\153\145\x79";
    function __construct()
    {
        if (class_exists("\115\x61\164\x68\x5f\x42\151\x67\111\156\164\145\x67\145\x72")) {
            goto Wa;
        }
        include_once dirname(__FILE__) . "\x2f\x4d\141\164\x68\57\102\151\x67\111\x6e\x74\145\147\x65\162\x2e\x70\x68\160";
        Wa:
        $this->configFile = CRYPT_RSA_OPENSSL_CONFIG;
        if (defined("\103\x52\131\x50\124\137\x52\123\101\137\115\x4f\x44\x45")) {
            goto gb;
        }
        switch (true) {
            case defined("\115\x41\124\110\137\102\111\x47\x49\x4e\124\105\x47\105\x52\137\x4f\x50\105\116\x53\x53\x4c\137\x44\111\x53\101\102\x4c\105"):
                define("\x43\122\x59\120\x54\x5f\x52\x53\x41\x5f\x4d\x4f\x44\105", CRYPT_RSA_MODE_INTERNAL);
                goto zk;
            case !function_exists("\x6f\160\145\x6e\163\163\x6c\137\160\x6b\145\171\137\x67\x65\164\137\x64\145\x74\141\151\154\x73"):
                define("\x43\122\131\x50\124\137\x52\123\x41\x5f\115\x4f\104\x45", CRYPT_RSA_MODE_INTERNAL);
                goto zk;
            case extension_loaded("\x6f\x70\x65\156\163\x73\x6c") && version_compare(PHP_VERSION, "\x34\x2e\62\x2e\60", "\x3e\x3d") && file_exists($this->configFile):
                ob_start();
                @phpinfo();
                $OK = ob_get_contents();
                ob_end_clean();
                preg_match_all("\43\x4f\160\145\x6e\123\x53\x4c\x20\50\110\145\x61\x64\x65\x72\x7c\114\x69\x62\162\141\x72\x79\x29\x20\x56\145\162\163\x69\157\x6e\x28\56\x2a\x29\x23\151\155", $OK, $cM);
                $Xk = array();
                if (empty($cM[1])) {
                    goto ll;
                }
                $uZ = 0;
                uu:
                if (!($uZ < count($cM[1]))) {
                    goto wJ;
                }
                $Hc = trim(str_replace("\75\x3e", '', strip_tags($cM[2][$uZ])));
                if (!preg_match("\57\50\134\x64\x2b\x5c\56\134\x64\53\134\56\x5c\x64\53\x29\57\151", $Hc, $cA)) {
                    goto FY;
                }
                $Xk[$cM[1][$uZ]] = $cA[0];
                goto kb;
                FY:
                $Xk[$cM[1][$uZ]] = $Hc;
                kb:
                Db:
                $uZ++;
                goto uu;
                wJ:
                ll:
                switch (true) {
                    case !isset($Xk["\x48\x65\141\x64\145\162"]):
                    case !isset($Xk["\114\151\x62\162\141\x72\171"]):
                    case $Xk["\x48\x65\141\x64\x65\162"] == $Xk["\x4c\x69\x62\x72\x61\162\x79"]:
                    case version_compare($Xk["\110\x65\141\144\145\162"], "\61\56\x30\x2e\60") >= 0 && version_compare($Xk["\114\x69\142\x72\x61\x72\x79"], "\61\56\60\x2e\x30") >= 0:
                        define("\x43\122\x59\120\124\x5f\122\x53\x41\x5f\115\x4f\x44\105", CRYPT_RSA_MODE_OPENSSL);
                        goto aB;
                    default:
                        define("\x43\x52\x59\120\124\137\x52\x53\101\x5f\115\x4f\104\x45", CRYPT_RSA_MODE_INTERNAL);
                        define("\x4d\x41\124\110\x5f\x42\x49\x47\x49\x4e\x54\x45\107\105\x52\137\117\120\x45\x4e\x53\x53\x4c\137\104\x49\123\101\x42\114\105", true);
                }
                zR:
                aB:
                goto zk;
            default:
                define("\103\122\x59\120\x54\137\x52\123\x41\x5f\x4d\x4f\x44\105", CRYPT_RSA_MODE_INTERNAL);
        }
        qY:
        zk:
        gb:
        $this->zero = new Math_BigInteger();
        $this->one = new Math_BigInteger(1);
        $this->hash = new Crypt_Hash("\163\x68\141\61");
        $this->hLen = $this->hash->getLength();
        $this->hashName = "\x73\x68\x61\61";
        $this->mgfHash = new Crypt_Hash("\x73\x68\x61\61");
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function Crypt_RSA()
    {
        $this->__construct();
    }
    function createKey($YP = 1024, $Y4 = false, $wB = array())
    {
        if (defined("\x43\122\x59\x50\x54\x5f\122\123\x41\137\x45\x58\x50\117\116\x45\x4e\x54")) {
            goto nl;
        }
        define("\x43\122\x59\x50\124\137\x52\123\101\x5f\x45\x58\x50\117\116\105\116\x54", "\66\x35\x35\63\x37");
        nl:
        if (defined("\103\122\x59\120\124\x5f\x52\123\x41\137\x53\x4d\x41\x4c\x4c\x45\x53\x54\x5f\120\x52\x49\x4d\105")) {
            goto yV;
        }
        define("\103\x52\x59\x50\x54\x5f\122\123\x41\137\x53\x4d\x41\x4c\114\105\x53\x54\x5f\x50\122\111\x4d\105", 4096);
        yV:
        if (!(CRYPT_RSA_MODE == CRYPT_RSA_MODE_OPENSSL && $YP >= 384 && CRYPT_RSA_EXPONENT == 65537)) {
            goto W5;
        }
        $fx = array();
        if (!isset($this->configFile)) {
            goto kJ;
        }
        $fx["\143\x6f\156\146\151\x67"] = $this->configFile;
        kJ:
        $T1 = openssl_pkey_new(array("\x70\162\x69\166\x61\164\x65\x5f\x6b\x65\x79\x5f\142\151\164\x73" => $YP) + $fx);
        openssl_pkey_export($T1, $CU, null, $fx);
        $W5 = openssl_pkey_get_details($T1);
        $W5 = $W5["\153\x65\171"];
        $CU = call_user_func_array(array($this, "\137\143\x6f\156\x76\145\x72\x74\120\162\151\x76\x61\164\145\x4b\x65\171"), array_values($this->_parseKey($CU, CRYPT_RSA_PRIVATE_FORMAT_PKCS1)));
        $W5 = call_user_func_array(array($this, "\137\143\x6f\156\166\145\x72\x74\x50\165\142\x6c\x69\x63\x4b\x65\171"), array_values($this->_parseKey($W5, CRYPT_RSA_PUBLIC_FORMAT_PKCS1)));
        eL:
        if (!(openssl_error_string() !== false)) {
            goto Eg;
        }
        goto eL;
        Eg:
        return array("\x70\162\151\166\x61\164\145\153\145\171" => $CU, "\x70\x75\142\154\x69\143\153\145\x79" => $W5, "\160\x61\162\x74\x69\x61\154\x6b\145\x79" => false);
        W5:
        static $fW;
        if (isset($fW)) {
            goto uB;
        }
        $fW = new Math_BigInteger(CRYPT_RSA_EXPONENT);
        uB:
        extract($this->_generateMinMax($YP));
        $Qb = $b8;
        $Ml = $YP >> 1;
        if ($Ml > CRYPT_RSA_SMALLEST_PRIME) {
            goto rA;
        }
        $YE = 2;
        goto gq;
        rA:
        $YE = floor($YP / CRYPT_RSA_SMALLEST_PRIME);
        $Ml = CRYPT_RSA_SMALLEST_PRIME;
        gq:
        extract($this->_generateMinMax($Ml + $YP % $Ml));
        $gn = $nx;
        extract($this->_generateMinMax($Ml));
        $WH = new Math_BigInteger();
        $xJ = $this->one->copy();
        if (!empty($wB)) {
            goto CP;
        }
        $ou = $Xr = $Ds = array();
        $gw = array("\164\x6f\x70" => $this->one->copy(), "\x62\157\164\164\157\x6d" => false);
        goto ky;
        CP:
        extract(unserialize($wB));
        ky:
        $zJ = time();
        $JF = count($Ds) + 1;
        U5:
        $uZ = $JF;
        Ps:
        if (!($uZ <= $YE)) {
            goto et;
        }
        if (!($Y4 !== false)) {
            goto Qu;
        }
        $Y4 -= time() - $zJ;
        $zJ = time();
        if (!($Y4 <= 0)) {
            goto k4;
        }
        return array("\160\x72\x69\166\141\164\145\x6b\145\171" => '', "\160\x75\142\154\151\x63\x6b\145\x79" => '', "\160\x61\x72\x74\x69\x61\154\153\x65\x79" => serialize(array("\160\x72\x69\x6d\x65\x73" => $Ds, "\143\x6f\145\146\146\x69\x63\x69\x65\156\164\163" => $Xr, "\154\143\155" => $gw, "\145\170\160\x6f\x6e\x65\156\164\x73" => $ou)));
        k4:
        Qu:
        if ($uZ == $YE) {
            goto Uc;
        }
        $Ds[$uZ] = $WH->randomPrime($b8, $nx, $Y4);
        goto bN;
        Uc:
        list($b8, $Ml) = $Qb->divide($xJ);
        if ($Ml->equals($this->zero)) {
            goto FR;
        }
        $b8 = $b8->add($this->one);
        FR:
        $Ds[$uZ] = $WH->randomPrime($b8, $gn, $Y4);
        bN:
        if (!($Ds[$uZ] === false)) {
            goto Rq;
        }
        if (count($Ds) > 1) {
            goto iy;
        }
        array_pop($Ds);
        $rL = serialize(array("\160\x72\151\x6d\145\163" => $Ds, "\x63\157\x65\x66\x66\151\x63\x69\145\156\x74\x73" => $Xr, "\x6c\x63\155" => $gw, "\145\170\160\x6f\156\x65\x6e\x74\x73" => $ou));
        goto c5;
        iy:
        $rL = '';
        c5:
        return array("\x70\162\151\166\x61\x74\145\153\x65\171" => '', "\160\x75\142\x6c\151\x63\153\x65\171" => '', "\x70\x61\162\x74\151\x61\x6c\153\x65\x79" => $rL);
        Rq:
        if (!($uZ > 2)) {
            goto Gb;
        }
        $Xr[$uZ] = $xJ->modInverse($Ds[$uZ]);
        Gb:
        $xJ = $xJ->multiply($Ds[$uZ]);
        $Ml = $Ds[$uZ]->subtract($this->one);
        $gw["\164\157\160"] = $gw["\x74\x6f\160"]->multiply($Ml);
        $gw["\x62\157\x74\164\x6f\x6d"] = $gw["\142\157\x74\164\x6f\155"] === false ? $Ml : $gw["\142\157\x74\x74\157\155"]->gcd($Ml);
        $ou[$uZ] = $fW->modInverse($Ml);
        cH:
        $uZ++;
        goto Ps;
        et:
        list($Ml) = $gw["\x74\x6f\160"]->divide($gw["\142\157\164\164\x6f\155"]);
        $ya = $Ml->gcd($fW);
        $JF = 1;
        if (!$ya->equals($this->one)) {
            goto U5;
        }
        MJ:
        $pi = $fW->modInverse($Ml);
        $Xr[2] = $Ds[2]->modInverse($Ds[1]);
        return array("\160\x72\151\x76\141\164\x65\153\x65\171" => $this->_convertPrivateKey($xJ, $fW, $pi, $Ds, $ou, $Xr), "\x70\x75\x62\154\x69\x63\x6b\145\171" => $this->_convertPublicKey($xJ, $fW), "\x70\x61\x72\164\151\141\154\x6b\x65\x79" => false);
    }
    function _convertPrivateKey($xJ, $fW, $pi, $Ds, $ou, $Xr)
    {
        $to = $this->privateKeyFormat != CRYPT_RSA_PRIVATE_FORMAT_XML;
        $YE = count($Ds);
        $sV = array("\166\145\x72\163\x69\x6f\156" => $YE == 2 ? chr(0) : chr(1), "\x6d\157\144\165\x6c\165\163" => $xJ->toBytes($to), "\160\x75\x62\x6c\x69\143\x45\170\x70\157\156\x65\x6e\x74" => $fW->toBytes($to), "\160\x72\151\x76\141\x74\x65\x45\x78\160\157\156\x65\156\x74" => $pi->toBytes($to), "\160\162\151\x6d\x65\x31" => $Ds[1]->toBytes($to), "\160\x72\151\x6d\145\62" => $Ds[2]->toBytes($to), "\x65\x78\x70\x6f\156\145\x6e\164\x31" => $ou[1]->toBytes($to), "\x65\x78\x70\157\156\x65\x6e\x74\62" => $ou[2]->toBytes($to), "\x63\157\145\146\x66\x69\x63\151\145\x6e\x74" => $Xr[2]->toBytes($to));
        switch ($this->privateKeyFormat) {
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
                if (!($YE != 2)) {
                    goto Fj;
                }
                return false;
                Fj:
                return "\x3c\122\123\101\113\145\171\126\x61\154\165\x65\76\xd\xa" . "\x20\x20\74\115\x6f\144\x75\x6c\165\163\76" . base64_encode($sV["\x6d\157\x64\165\x6c\165\163"]) . "\74\57\x4d\x6f\144\165\154\165\163\76\15\12" . "\x20\40\x3c\x45\x78\160\x6f\156\x65\x6e\x74\x3e" . base64_encode($sV["\160\x75\x62\154\x69\x63\x45\170\x70\157\156\x65\156\x74"]) . "\74\x2f\x45\170\160\x6f\156\x65\x6e\x74\76\xd\xa" . "\40\40\74\x50\76" . base64_encode($sV["\160\x72\x69\155\145\61"]) . "\x3c\x2f\x50\76\xd\xa" . "\40\40\x3c\121\76" . base64_encode($sV["\160\162\151\155\145\x32"]) . "\74\57\121\76\xd\12" . "\40\x20\x3c\x44\120\x3e" . base64_encode($sV["\x65\x78\160\157\156\x65\x6e\164\61"]) . "\x3c\57\104\120\x3e\xd\12" . "\40\40\74\x44\121\76" . base64_encode($sV["\145\170\x70\157\156\x65\x6e\x74\x32"]) . "\74\57\x44\x51\x3e\xd\12" . "\x20\40\x3c\x49\x6e\166\145\162\x73\x65\121\76" . base64_encode($sV["\143\157\145\146\x66\x69\x63\x69\x65\156\164"]) . "\x3c\x2f\x49\x6e\166\145\x72\x73\145\x51\x3e\15\12" . "\40\x20\x3c\104\x3e" . base64_encode($sV["\160\162\151\x76\x61\164\x65\105\170\x70\157\156\145\156\164"]) . "\74\x2f\104\76\15\xa" . "\x3c\57\122\123\101\113\145\171\x56\141\154\165\145\76";
                goto rf;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                if (!($YE != 2)) {
                    goto Rs;
                }
                return false;
                Rs:
                $O8 = "\x50\165\x54\124\x59\55\x55\x73\145\162\x2d\x4b\x65\x79\x2d\x46\151\x6c\x65\x2d\62\72\40\163\x73\x68\55\162\163\x61\15\12\x45\156\143\x72\171\160\164\151\x6f\156\72\40";
                $Y_ = !empty($this->password) || is_string($this->password) ? "\141\145\163\x32\65\x36\x2d\x63\142\143" : "\156\x6f\x6e\145";
                $O8 .= $Y_;
                $O8 .= "\15\xa\x43\x6f\x6d\x6d\x65\156\x74\72\40" . $this->comment . "\xd\12";
                $BW = pack("\116\141\x2a\116\141\x2a\116\141\52", strlen("\163\x73\150\55\x72\x73\141"), "\x73\x73\150\55\162\163\x61", strlen($sV["\160\x75\x62\154\151\x63\105\x78\160\x6f\x6e\145\156\164"]), $sV["\160\165\142\x6c\151\143\105\x78\x70\x6f\156\145\x6e\164"], strlen($sV["\x6d\x6f\144\x75\154\165\x73"]), $sV["\155\157\144\165\154\x75\x73"]);
                $lO = pack("\116\x61\52\116\141\52\116\x61\52\116\x61\52", strlen("\163\163\x68\55\x72\x73\x61"), "\x73\x73\150\55\162\x73\141", strlen($Y_), $Y_, strlen($this->comment), $this->comment, strlen($BW), $BW);
                $BW = base64_encode($BW);
                $O8 .= "\x50\x75\142\154\151\143\55\114\x69\156\145\x73\72\40" . (strlen($BW) + 63 >> 6) . "\15\12";
                $O8 .= chunk_split($BW, 64);
                $ke = pack("\x4e\141\x2a\116\141\x2a\x4e\141\x2a\x4e\x61\52", strlen($sV["\x70\x72\x69\166\x61\164\145\105\x78\x70\157\156\145\x6e\164"]), $sV["\160\162\x69\x76\x61\x74\145\105\x78\x70\x6f\x6e\145\156\164"], strlen($sV["\x70\162\151\155\145\61"]), $sV["\160\x72\x69\155\145\61"], strlen($sV["\160\162\x69\x6d\x65\62"]), $sV["\x70\162\151\x6d\x65\x32"], strlen($sV["\143\x6f\x65\x66\x66\x69\x63\151\145\156\x74"]), $sV["\x63\157\x65\x66\146\x69\143\x69\x65\156\x74"]);
                if (empty($this->password) && !is_string($this->password)) {
                    goto st;
                }
                $ke .= crypt_random_string(16 - (strlen($ke) & 15));
                $lO .= pack("\x4e\x61\x2a", strlen($ke), $ke);
                if (class_exists("\103\x72\x79\160\x74\x5f\101\105\x53")) {
                    goto Mf;
                }
                include_once "\x43\x72\171\x70\164\57\101\105\123\x2e\x70\150\160";
                Mf:
                $fz = 0;
                $IG = '';
                l1:
                if (!(strlen($IG) < 32)) {
                    goto hC;
                }
                $Ml = pack("\116\141\x2a", $fz++, $this->password);
                $IG .= pack("\x48\x2a", sha1($Ml));
                goto l1;
                hC:
                $IG = substr($IG, 0, 32);
                $aG = new Crypt_AES();
                $aG->setKey($IG);
                $aG->disablePadding();
                $ke = $aG->encrypt($ke);
                $lV = "\x70\165\x74\164\x79\x2d\x70\162\x69\166\141\164\145\x2d\x6b\x65\171\x2d\x66\151\154\x65\55\155\141\143\55\153\x65\x79" . $this->password;
                goto XN;
                st:
                $lO .= pack("\116\141\x2a", strlen($ke), $ke);
                $lV = "\160\x75\164\x74\171\x2d\x70\162\x69\x76\141\x74\145\x2d\x6b\145\171\55\146\x69\x6c\145\55\155\141\143\55\x6b\145\171";
                XN:
                $ke = base64_encode($ke);
                $O8 .= "\x50\162\151\166\141\164\x65\x2d\114\151\x6e\145\x73\x3a\x20" . (strlen($ke) + 63 >> 6) . "\15\12";
                $O8 .= chunk_split($ke, 64);
                if (class_exists("\103\162\x79\x70\x74\x5f\110\141\163\150")) {
                    goto CO;
                }
                include_once "\103\162\171\x70\164\57\110\141\x73\x68\x2e\160\x68\160";
                CO:
                $Y9 = new Crypt_Hash("\163\x68\x61\x31");
                $Y9->setKey(pack("\x48\52", sha1($lV)));
                $O8 .= "\x50\162\x69\166\141\164\145\x2d\115\x41\x43\72\40" . bin2hex($Y9->hash($lO)) . "\15\12";
                return $O8;
            default:
                $OP = array();
                foreach ($sV as $zV => $pj) {
                    $OP[$zV] = pack("\x43\141\x2a\141\x2a", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($pj)), $pj);
                    zE:
                }
                DP:
                $i2 = implode('', $OP);
                if (!($YE > 2)) {
                    goto iP;
                }
                $Jq = '';
                $uZ = 3;
                fR:
                if (!($uZ <= $YE)) {
                    goto z9;
                }
                $yJ = pack("\103\141\52\141\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($Ds[$uZ]->toBytes(true))), $Ds[$uZ]->toBytes(true));
                $yJ .= pack("\x43\x61\52\x61\x2a", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($ou[$uZ]->toBytes(true))), $ou[$uZ]->toBytes(true));
                $yJ .= pack("\x43\x61\x2a\x61\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($Xr[$uZ]->toBytes(true))), $Xr[$uZ]->toBytes(true));
                $Jq .= pack("\103\x61\52\141\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($yJ)), $yJ);
                vU:
                $uZ++;
                goto fR;
                z9:
                $i2 .= pack("\x43\141\x2a\x61\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($Jq)), $Jq);
                iP:
                $i2 = pack("\103\141\52\x61\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($i2)), $i2);
                if (!($this->privateKeyFormat == CRYPT_RSA_PRIVATE_FORMAT_PKCS8)) {
                    goto eo;
                }
                $k7 = pack("\110\x2a", "\x33\x30\60\x64\60\66\x30\71\x32\141\x38\66\x34\x38\70\x36\146\x37\60\144\60\x31\x30\61\60\x31\60\65\x30\60");
                $i2 = pack("\x43\x61\x2a\141\x2a\x43\141\52\x61\x2a", CRYPT_RSA_ASN1_INTEGER, "\x1\0", $k7, 4, $this->_encodeLength(strlen($i2)), $i2);
                $i2 = pack("\103\141\x2a\141\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($i2)), $i2);
                if (!empty($this->password) || is_string($this->password)) {
                    goto O1;
                }
                $i2 = "\x2d\55\x2d\x2d\x2d\102\105\107\x49\116\40\120\122\111\126\x41\124\105\40\113\x45\x59\55\55\x2d\55\55\xd\12" . chunk_split(base64_encode($i2), 64) . "\x2d\x2d\55\x2d\55\105\116\x44\40\x50\x52\111\126\101\x54\x45\x20\x4b\x45\x59\x2d\x2d\55\x2d\x2d";
                goto WN;
                O1:
                $Lu = crypt_random_string(8);
                $Tb = 2048;
                if (class_exists("\103\x72\171\160\x74\137\104\x45\123")) {
                    goto j1;
                }
                include_once "\x43\x72\x79\160\x74\x2f\x44\105\x53\56\x70\150\x70";
                j1:
                $aG = new Crypt_DES();
                $aG->setPassword($this->password, "\x70\x62\153\x64\146\x31", "\155\x64\65", $Lu, $Tb);
                $i2 = $aG->encrypt($i2);
                $TC = pack("\103\x61\x2a\141\x2a\x43\x61\x2a\x4e", CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($Lu)), $Lu, CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(4), $Tb);
                $PI = "\x2a\206\x48\206\xf7\15\x1\x5\3";
                $XJ = pack("\x43\141\52\141\x2a\103\141\x2a\x61\x2a", CRYPT_RSA_ASN1_OBJECT, $this->_encodeLength(strlen($PI)), $PI, CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($TC)), $TC);
                $i2 = pack("\x43\141\x2a\x61\x2a\103\x61\x2a\x61\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($XJ)), $XJ, CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($i2)), $i2);
                $i2 = pack("\x43\x61\52\141\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($i2)), $i2);
                $i2 = "\x2d\55\x2d\x2d\55\x42\x45\107\x49\116\40\105\x4e\x43\x52\x59\120\124\x45\104\x20\x50\122\x49\126\101\124\105\40\x4b\x45\131\x2d\x2d\x2d\x2d\x2d\xd\12" . chunk_split(base64_encode($i2), 64) . "\55\55\x2d\x2d\x2d\x45\x4e\x44\x20\x45\116\103\122\x59\120\x54\x45\x44\x20\x50\x52\111\126\x41\x54\x45\x20\113\105\131\55\55\x2d\x2d\x2d";
                WN:
                return $i2;
                eo:
                if (!empty($this->password) || is_string($this->password)) {
                    goto k5;
                }
                $i2 = "\x2d\x2d\x2d\x2d\55\x42\105\107\x49\x4e\x20\122\123\101\40\x50\122\x49\126\x41\124\105\40\x4b\x45\x59\x2d\x2d\x2d\x2d\55\15\xa" . chunk_split(base64_encode($i2), 64) . "\x2d\x2d\x2d\x2d\55\105\116\104\x20\122\123\101\x20\x50\122\111\x56\101\x54\105\x20\113\105\131\x2d\x2d\x2d\x2d\x2d";
                goto IN;
                k5:
                $Bc = crypt_random_string(8);
                $IG = pack("\110\x2a", md5($this->password . $Bc));
                $IG .= substr(pack("\110\52", md5($IG . $this->password . $Bc)), 0, 8);
                if (class_exists("\x43\x72\x79\x70\x74\x5f\124\162\x69\x70\154\145\104\x45\x53")) {
                    goto qt;
                }
                include_once "\103\x72\171\x70\164\x2f\x54\x72\x69\x70\154\145\x44\105\123\56\x70\x68\x70";
                qt:
                $dE = new Crypt_TripleDES();
                $dE->setKey($IG);
                $dE->setIV($Bc);
                $Bc = strtoupper(bin2hex($Bc));
                $i2 = "\x2d\x2d\x2d\55\55\x42\105\107\111\116\40\x52\123\x41\x20\120\122\x49\x56\x41\x54\105\x20\113\x45\x59\x2d\x2d\x2d\x2d\x2d\15\12" . "\120\x72\157\x63\55\x54\x79\160\x65\x3a\40\64\54\x45\116\103\x52\131\x50\124\x45\x44\xd\xa" . "\x44\x45\113\x2d\x49\156\146\157\72\x20\x44\105\x53\55\x45\104\105\63\55\x43\102\103\54{$Bc}\15\xa" . "\xd\xa" . chunk_split(base64_encode($dE->encrypt($i2)), 64) . "\x2d\55\55\x2d\x2d\x45\116\104\40\x52\123\x41\x20\x50\122\x49\126\x41\x54\105\40\x4b\105\131\x2d\55\x2d\55\x2d";
                IN:
                return $i2;
        }
        Mw:
        rf:
    }
    function _convertPublicKey($xJ, $fW)
    {
        $to = $this->publicKeyFormat != CRYPT_RSA_PUBLIC_FORMAT_XML;
        $qH = $xJ->toBytes($to);
        $zB = $fW->toBytes($to);
        switch ($this->publicKeyFormat) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                return array("\145" => $fW->copy(), "\156" => $xJ->copy());
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                return "\x3c\122\x53\101\x4b\x65\x79\x56\x61\x6c\165\x65\x3e\xd\xa" . "\40\40\74\x4d\x6f\144\165\x6c\x75\x73\76" . base64_encode($qH) . "\x3c\57\115\x6f\x64\x75\x6c\x75\x73\76\xd\xa" . "\x20\40\74\x45\170\160\157\156\145\156\164\76" . base64_encode($zB) . "\x3c\x2f\x45\170\x70\x6f\x6e\x65\156\164\x3e\xd\xa" . "\74\57\x52\x53\x41\113\145\171\x56\x61\154\x75\x65\x3e";
                goto oE;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $qx = pack("\x4e\141\x2a\x4e\x61\x2a\116\x61\52", strlen("\x73\163\150\55\162\163\x61"), "\x73\x73\150\55\162\x73\x61", strlen($zB), $zB, strlen($qH), $qH);
                $qx = "\163\163\150\55\x72\163\x61\40" . base64_encode($qx) . "\x20" . $this->comment;
                return $qx;
            default:
                $OP = array("\155\x6f\144\165\x6c\165\163" => pack("\x43\x61\52\141\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($qH)), $qH), "\x70\x75\x62\154\x69\143\105\170\160\157\156\145\156\x74" => pack("\103\141\x2a\x61\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($zB)), $zB));
                $qx = pack("\103\141\52\141\52\x61\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OP["\155\157\x64\165\x6c\x75\163"]) + strlen($OP["\x70\x75\x62\154\151\143\105\170\x70\x6f\156\x65\156\164"])), $OP["\x6d\157\144\x75\x6c\x75\x73"], $OP["\160\165\x62\154\151\x63\x45\170\x70\x6f\156\145\x6e\164"]);
                if ($this->publicKeyFormat == CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW) {
                    goto S4;
                }
                $k7 = pack("\x48\52", "\63\60\x30\144\60\66\x30\x39\62\x61\70\x36\64\x38\x38\66\x66\67\60\x64\x30\61\60\x31\60\61\x30\x35\60\x30");
                $qx = chr(0) . $qx;
                $qx = chr(3) . $this->_encodeLength(strlen($qx)) . $qx;
                $qx = pack("\103\x61\52\141\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($k7 . $qx)), $k7 . $qx);
                $qx = "\x2d\x2d\55\55\55\x42\x45\107\111\x4e\40\120\x55\x42\x4c\x49\103\40\113\105\131\55\x2d\x2d\x2d\x2d\15\xa" . chunk_split(base64_encode($qx), 64) . "\x2d\x2d\55\x2d\x2d\x45\x4e\x44\40\120\125\102\x4c\111\103\40\113\105\131\55\55\55\55\x2d";
                goto vb;
                S4:
                $qx = "\x2d\x2d\55\55\x2d\102\x45\x47\x49\x4e\40\122\123\101\x20\x50\x55\x42\114\111\x43\40\x4b\105\x59\55\x2d\x2d\x2d\x2d\15\xa" . chunk_split(base64_encode($qx), 64) . "\x2d\x2d\x2d\x2d\55\x45\x4e\x44\40\x52\x53\101\x20\120\x55\102\x4c\111\x43\40\x4b\x45\131\55\x2d\x2d\x2d\55";
                vb:
                return $qx;
        }
        rZ:
        oE:
    }
    function _parseKey($O8, $Tf)
    {
        if (!($Tf != CRYPT_RSA_PUBLIC_FORMAT_RAW && !is_string($O8))) {
            goto nH;
        }
        return false;
        nH:
        switch ($Tf) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                if (is_array($O8)) {
                    goto Cw;
                }
                return false;
                Cw:
                $OP = array();
                switch (true) {
                    case isset($O8["\x65"]):
                        $OP["\160\165\x62\x6c\151\143\105\x78\x70\x6f\156\145\156\x74"] = $O8["\145"]->copy();
                        goto P4;
                    case isset($O8["\145\x78\x70\x6f\x6e\x65\x6e\164"]):
                        $OP["\x70\165\142\x6c\x69\x63\105\170\x70\x6f\156\145\156\164"] = $O8["\x65\170\x70\x6f\156\x65\x6e\164"]->copy();
                        goto P4;
                    case isset($O8["\160\x75\142\154\151\x63\105\x78\160\x6f\x6e\x65\x6e\x74"]):
                        $OP["\x70\165\x62\x6c\151\143\x45\170\x70\x6f\156\145\x6e\x74"] = $O8["\x70\x75\142\154\151\x63\105\x78\160\x6f\156\x65\x6e\x74"]->copy();
                        goto P4;
                    case isset($O8[0]):
                        $OP["\x70\x75\142\154\151\x63\x45\x78\160\157\156\x65\x6e\x74"] = $O8[0]->copy();
                }
                Lm:
                P4:
                switch (true) {
                    case isset($O8["\x6e"]):
                        $OP["\x6d\157\144\x75\x6c\165\x73"] = $O8["\156"]->copy();
                        goto n3;
                    case isset($O8["\155\157\144\165\x6c\x6f"]):
                        $OP["\155\x6f\x64\x75\x6c\x75\x73"] = $O8["\x6d\x6f\144\x75\154\x6f"]->copy();
                        goto n3;
                    case isset($O8["\155\x6f\144\x75\x6c\165\x73"]):
                        $OP["\155\x6f\144\x75\154\165\x73"] = $O8["\x6d\157\144\x75\154\165\x73"]->copy();
                        goto n3;
                    case isset($O8[1]):
                        $OP["\155\157\x64\165\x6c\x75\x73"] = $O8[1]->copy();
                }
                Vm:
                n3:
                return isset($OP["\x6d\157\x64\x75\x6c\x75\x73"]) && isset($OP["\160\x75\142\154\151\143\x45\170\160\x6f\156\145\156\164"]) ? $OP : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS8:
            case CRYPT_RSA_PUBLIC_FORMAT_PKCS1:
                if (preg_match("\43\104\105\x4b\55\111\156\146\x6f\x3a\x20\50\x2e\53\x29\x2c\50\x2e\53\x29\43", $O8, $cM)) {
                    goto JG;
                }
                $Nh = $this->_extractBER($O8);
                goto KC;
                JG:
                $Bc = pack("\x48\x2a", trim($cM[2]));
                $IG = pack("\110\x2a", md5($this->password . substr($Bc, 0, 8)));
                $IG .= pack("\110\x2a", md5($IG . $this->password . substr($Bc, 0, 8)));
                $O8 = preg_replace("\43\136\x28\77\72\x50\x72\157\x63\x2d\124\x79\160\x65\174\104\105\113\55\x49\156\x66\157\x29\72\40\56\x2a\43\x6d", '', $O8);
                $le = $this->_extractBER($O8);
                if (!($le === false)) {
                    goto gM;
                }
                $le = $O8;
                gM:
                switch ($cM[1]) {
                    case "\x41\105\x53\55\62\x35\x36\55\x43\102\103":
                        if (class_exists("\103\x72\171\x70\x74\137\x41\105\x53")) {
                            goto s5;
                        }
                        include_once "\103\x72\x79\160\x74\57\x41\x45\123\x2e\x70\150\160";
                        s5:
                        $aG = new Crypt_AES();
                        goto uG;
                    case "\101\x45\x53\x2d\61\x32\x38\x2d\x43\102\103":
                        if (class_exists("\103\x72\x79\160\164\x5f\101\x45\123")) {
                            goto Qw;
                        }
                        include_once "\x43\162\x79\160\164\x2f\x41\105\123\56\160\x68\160";
                        Qw:
                        $IG = substr($IG, 0, 16);
                        $aG = new Crypt_AES();
                        goto uG;
                    case "\x44\x45\x53\55\105\x44\105\63\55\103\x46\x42":
                        if (class_exists("\103\162\171\160\164\137\124\x72\x69\160\x6c\x65\x44\x45\x53")) {
                            goto Ao;
                        }
                        include_once "\x43\x72\171\160\164\x2f\124\162\151\160\154\145\x44\105\x53\56\x70\150\160";
                        Ao:
                        $aG = new Crypt_TripleDES(CRYPT_DES_MODE_CFB);
                        goto uG;
                    case "\x44\x45\123\55\105\104\105\63\55\103\x42\103":
                        if (class_exists("\x43\162\171\160\x74\x5f\x54\162\151\x70\x6c\145\104\105\x53")) {
                            goto Gx;
                        }
                        include_once "\103\x72\x79\160\x74\57\124\x72\151\160\154\145\x44\105\123\x2e\x70\150\x70";
                        Gx:
                        $IG = substr($IG, 0, 24);
                        $aG = new Crypt_TripleDES();
                        goto uG;
                    case "\x44\x45\x53\x2d\103\x42\103":
                        if (class_exists("\x43\x72\171\x70\164\137\104\x45\123")) {
                            goto pi;
                        }
                        include_once "\103\x72\171\160\164\57\x44\105\123\x2e\x70\x68\x70";
                        pi:
                        $aG = new Crypt_DES();
                        goto uG;
                    default:
                        return false;
                }
                ig:
                uG:
                $aG->setKey($IG);
                $aG->setIV($Bc);
                $Nh = $aG->decrypt($le);
                KC:
                if (!($Nh !== false)) {
                    goto vH;
                }
                $O8 = $Nh;
                vH:
                $OP = array();
                if (!(ord($this->_string_shift($O8)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto aA;
                }
                return false;
                aA:
                if (!($this->_decodeLength($O8) != strlen($O8))) {
                    goto j2;
                }
                return false;
                j2:
                $dJ = ord($this->_string_shift($O8));
                if (!($dJ == CRYPT_RSA_ASN1_INTEGER && substr($O8, 0, 3) == "\1\x0\60")) {
                    goto MD;
                }
                $this->_string_shift($O8, 3);
                $dJ = CRYPT_RSA_ASN1_SEQUENCE;
                MD:
                if (!($dJ == CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto Ia;
                }
                $Ml = $this->_string_shift($O8, $this->_decodeLength($O8));
                if (!(ord($this->_string_shift($Ml)) != CRYPT_RSA_ASN1_OBJECT)) {
                    goto tP;
                }
                return false;
                tP:
                $iI = $this->_decodeLength($Ml);
                switch ($this->_string_shift($Ml, $iI)) {
                    case "\x2a\206\110\206\xf7\xd\x1\x1\x1":
                        goto C0;
                    case "\x2a\206\x48\x86\367\xd\x1\x5\3":
                        if (!(ord($this->_string_shift($Ml)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                            goto zP;
                        }
                        return false;
                        zP:
                        if (!($this->_decodeLength($Ml) != strlen($Ml))) {
                            goto SD;
                        }
                        return false;
                        SD:
                        $this->_string_shift($Ml);
                        $Lu = $this->_string_shift($Ml, $this->_decodeLength($Ml));
                        if (!(ord($this->_string_shift($Ml)) != CRYPT_RSA_ASN1_INTEGER)) {
                            goto HC;
                        }
                        return false;
                        HC:
                        $this->_decodeLength($Ml);
                        list(, $Tb) = unpack("\x4e", str_pad($Ml, 4, chr(0), STR_PAD_LEFT));
                        $this->_string_shift($O8);
                        $iI = $this->_decodeLength($O8);
                        if (!(strlen($O8) != $iI)) {
                            goto xU;
                        }
                        return false;
                        xU:
                        if (class_exists("\x43\162\x79\x70\x74\x5f\104\105\x53")) {
                            goto Mh;
                        }
                        include_once "\103\x72\171\x70\x74\x2f\104\x45\123\56\160\x68\x70";
                        Mh:
                        $aG = new Crypt_DES();
                        $aG->setPassword($this->password, "\x70\x62\x6b\x64\146\x31", "\x6d\x64\x35", $Lu, $Tb);
                        $O8 = $aG->decrypt($O8);
                        if (!($O8 === false)) {
                            goto Y8;
                        }
                        return false;
                        Y8:
                        return $this->_parseKey($O8, CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
                    default:
                        return false;
                }
                C3:
                C0:
                $dJ = ord($this->_string_shift($O8));
                $this->_decodeLength($O8);
                if (!($dJ == CRYPT_RSA_ASN1_BITSTRING)) {
                    goto Mo;
                }
                $this->_string_shift($O8);
                Mo:
                if (!(ord($this->_string_shift($O8)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto JQ;
                }
                return false;
                JQ:
                if (!($this->_decodeLength($O8) != strlen($O8))) {
                    goto mV;
                }
                return false;
                mV:
                $dJ = ord($this->_string_shift($O8));
                Ia:
                if (!($dJ != CRYPT_RSA_ASN1_INTEGER)) {
                    goto xl;
                }
                return false;
                xl:
                $iI = $this->_decodeLength($O8);
                $Ml = $this->_string_shift($O8, $iI);
                if (!(strlen($Ml) != 1 || ord($Ml) > 2)) {
                    goto YA;
                }
                $OP["\155\x6f\x64\x75\x6c\165\163"] = new Math_BigInteger($Ml, 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP[$Tf == CRYPT_RSA_PUBLIC_FORMAT_PKCS1 ? "\160\165\142\154\x69\143\105\x78\x70\x6f\156\145\156\164" : "\x70\x72\x69\x76\141\x74\x65\x45\x78\160\157\156\145\156\x74"] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                return $OP;
                YA:
                if (!(ord($this->_string_shift($O8)) != CRYPT_RSA_ASN1_INTEGER)) {
                    goto K_;
                }
                return false;
                K_:
                $iI = $this->_decodeLength($O8);
                $OP["\x6d\x6f\x64\165\x6c\x75\x73"] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\160\x75\142\x6c\x69\143\105\170\x70\157\x6e\145\156\164"] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\160\162\151\166\x61\164\145\105\x78\160\x6f\156\145\x6e\164"] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\x70\162\x69\155\145\163"] = array(1 => new Math_BigInteger($this->_string_shift($O8, $iI), 256));
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\160\x72\151\155\x65\x73"][] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\145\170\x70\157\156\x65\x6e\164\163"] = array(1 => new Math_BigInteger($this->_string_shift($O8, $iI), 256));
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\145\x78\x70\x6f\x6e\x65\x6e\x74\x73"][] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\x63\x6f\x65\x66\146\x69\143\151\x65\x6e\x74\x73"] = array(2 => new Math_BigInteger($this->_string_shift($O8, $iI), 256));
                if (empty($O8)) {
                    goto hl;
                }
                if (!(ord($this->_string_shift($O8)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto IQ;
                }
                return false;
                IQ:
                $this->_decodeLength($O8);
                Yp:
                if (empty($O8)) {
                    goto QA;
                }
                if (!(ord($this->_string_shift($O8)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto Kf;
                }
                return false;
                Kf:
                $this->_decodeLength($O8);
                $O8 = substr($O8, 1);
                $iI = $this->_decodeLength($O8);
                $OP["\160\x72\x69\155\x65\x73"][] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\145\170\x70\157\x6e\x65\156\164\163"][] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                $this->_string_shift($O8);
                $iI = $this->_decodeLength($O8);
                $OP["\x63\157\145\x66\146\151\143\151\x65\x6e\x74\x73"][] = new Math_BigInteger($this->_string_shift($O8, $iI), 256);
                goto Yp;
                QA:
                hl:
                return $OP;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $rO = explode("\40", $O8, 3);
                $O8 = isset($rO[1]) ? base64_decode($rO[1]) : false;
                if (!($O8 === false)) {
                    goto Ey;
                }
                return false;
                Ey:
                $a9 = isset($rO[2]) ? $rO[2] : false;
                $Gy = substr($O8, 0, 11) == "\0\0\0\x7\x73\x73\x68\55\162\163\141";
                if (!(strlen($O8) <= 4)) {
                    goto Ss;
                }
                return false;
                Ss:
                extract(unpack("\x4e\x6c\x65\x6e\x67\164\150", $this->_string_shift($O8, 4)));
                $zB = new Math_BigInteger($this->_string_shift($O8, $iI), -256);
                if (!(strlen($O8) <= 4)) {
                    goto gv;
                }
                return false;
                gv:
                extract(unpack("\116\154\145\156\x67\x74\x68", $this->_string_shift($O8, 4)));
                $qH = new Math_BigInteger($this->_string_shift($O8, $iI), -256);
                if ($Gy && strlen($O8)) {
                    goto ce;
                }
                return strlen($O8) ? false : array("\155\x6f\x64\165\154\x75\163" => $qH, "\x70\165\x62\154\151\143\x45\170\x70\157\156\145\156\164" => $zB, "\x63\x6f\x6d\x6d\145\156\x74" => $a9);
                goto rd;
                ce:
                if (!(strlen($O8) <= 4)) {
                    goto wz;
                }
                return false;
                wz:
                extract(unpack("\116\154\145\x6e\x67\x74\150", $this->_string_shift($O8, 4)));
                $iE = new Math_BigInteger($this->_string_shift($O8, $iI), -256);
                return strlen($O8) ? false : array("\x6d\157\144\x75\x6c\x75\x73" => $iE, "\160\165\x62\154\151\143\x45\170\160\x6f\x6e\x65\156\164" => $qH, "\x63\x6f\155\155\145\x6e\164" => $a9);
                rd:
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                $this->components = array();
                $qq = xml_parser_create("\125\124\x46\55\70");
                xml_set_object($qq, $this);
                xml_set_element_handler($qq, "\137\x73\x74\x61\x72\x74\137\145\x6c\145\x6d\145\x6e\164\137\150\x61\x6e\144\x6c\145\162", "\137\x73\x74\x6f\160\x5f\x65\154\145\x6d\x65\156\164\137\x68\141\156\x64\154\x65\162");
                xml_set_character_data_handler($qq, "\137\x64\x61\x74\141\x5f\150\x61\x6e\x64\154\145\x72");
                if (xml_parse($qq, "\x3c\x78\x6d\x6c\x3e" . $O8 . "\x3c\57\x78\x6d\154\x3e")) {
                    goto u7;
                }
                return false;
                u7:
                return isset($this->components["\155\157\x64\165\154\165\163"]) && isset($this->components["\x70\165\142\x6c\151\143\105\x78\160\x6f\x6e\x65\156\x74"]) ? $this->components : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                $OP = array();
                $O8 = preg_split("\43\134\x72\134\156\x7c\134\162\x7c\x5c\x6e\43", $O8);
                $Tf = trim(preg_replace("\x23\x50\165\124\x54\131\55\125\x73\145\162\x2d\113\x65\x79\55\x46\151\x6c\x65\55\62\72\40\x28\x2e\53\51\x23", "\44\61", $O8[0]));
                if (!($Tf != "\163\163\150\55\x72\163\141")) {
                    goto xi;
                }
                return false;
                xi:
                $Y_ = trim(preg_replace("\43\x45\156\x63\x72\x79\x70\x74\151\x6f\156\x3a\x20\50\56\53\x29\43", "\x24\x31", $O8[1]));
                $a9 = trim(preg_replace("\x23\x43\x6f\155\x6d\x65\156\x74\72\x20\50\56\x2b\x29\x23", "\44\61", $O8[2]));
                $qR = trim(preg_replace("\43\x50\x75\x62\x6c\x69\x63\x2d\114\151\x6e\x65\163\x3a\x20\50\x5c\144\53\51\43", "\44\x31", $O8[3]));
                $BW = base64_decode(implode('', array_map("\x74\x72\x69\x6d", array_slice($O8, 4, $qR))));
                $BW = substr($BW, 11);
                extract(unpack("\x4e\x6c\x65\156\147\164\150", $this->_string_shift($BW, 4)));
                $OP["\x70\165\142\x6c\151\143\x45\170\x70\157\x6e\x65\156\164"] = new Math_BigInteger($this->_string_shift($BW, $iI), -256);
                extract(unpack("\x4e\154\x65\x6e\x67\x74\150", $this->_string_shift($BW, 4)));
                $OP["\155\157\x64\165\154\165\x73"] = new Math_BigInteger($this->_string_shift($BW, $iI), -256);
                $Mm = trim(preg_replace("\43\120\x72\151\x76\141\164\x65\x2d\114\x69\x6e\x65\163\x3a\40\x28\x5c\144\x2b\x29\x23", "\x24\61", $O8[$qR + 4]));
                $ke = base64_decode(implode('', array_map("\164\x72\x69\155", array_slice($O8, $qR + 5, $Mm))));
                switch ($Y_) {
                    case "\141\x65\163\x32\x35\66\x2d\x63\x62\143":
                        if (class_exists("\103\x72\171\160\164\137\101\105\x53")) {
                            goto dI;
                        }
                        include_once "\x43\x72\171\x70\x74\x2f\101\x45\123\x2e\160\150\x70";
                        dI:
                        $IG = '';
                        $fz = 0;
                        eK:
                        if (!(strlen($IG) < 32)) {
                            goto xo;
                        }
                        $Ml = pack("\116\141\x2a", $fz++, $this->password);
                        $IG .= pack("\110\52", sha1($Ml));
                        goto eK;
                        xo:
                        $IG = substr($IG, 0, 32);
                        $aG = new Crypt_AES();
                }
                gl:
                GX:
                if (!($Y_ != "\x6e\157\x6e\x65")) {
                    goto UJ;
                }
                $aG->setKey($IG);
                $aG->disablePadding();
                $ke = $aG->decrypt($ke);
                if (!($ke === false)) {
                    goto UO;
                }
                return false;
                UO:
                UJ:
                extract(unpack("\x4e\154\145\x6e\147\164\x68", $this->_string_shift($ke, 4)));
                if (!(strlen($ke) < $iI)) {
                    goto ZX;
                }
                return false;
                ZX:
                $OP["\160\x72\x69\166\141\164\x65\x45\170\160\157\x6e\145\x6e\164"] = new Math_BigInteger($this->_string_shift($ke, $iI), -256);
                extract(unpack("\116\154\x65\x6e\147\164\x68", $this->_string_shift($ke, 4)));
                if (!(strlen($ke) < $iI)) {
                    goto eg;
                }
                return false;
                eg:
                $OP["\160\x72\x69\x6d\145\x73"] = array(1 => new Math_BigInteger($this->_string_shift($ke, $iI), -256));
                extract(unpack("\116\x6c\x65\156\x67\x74\150", $this->_string_shift($ke, 4)));
                if (!(strlen($ke) < $iI)) {
                    goto Wf;
                }
                return false;
                Wf:
                $OP["\x70\x72\151\155\145\163"][] = new Math_BigInteger($this->_string_shift($ke, $iI), -256);
                $Ml = $OP["\x70\x72\151\155\x65\x73"][1]->subtract($this->one);
                $OP["\145\170\x70\x6f\x6e\x65\x6e\164\163"] = array(1 => $OP["\x70\165\142\154\x69\143\x45\x78\160\x6f\156\145\156\x74"]->modInverse($Ml));
                $Ml = $OP["\x70\x72\x69\155\145\163"][2]->subtract($this->one);
                $OP["\x65\170\x70\x6f\x6e\145\x6e\164\x73"][] = $OP["\160\165\x62\154\x69\x63\105\x78\x70\157\x6e\145\156\x74"]->modInverse($Ml);
                extract(unpack("\116\x6c\145\x6e\x67\164\x68", $this->_string_shift($ke, 4)));
                if (!(strlen($ke) < $iI)) {
                    goto fZ;
                }
                return false;
                fZ:
                $OP["\x63\157\145\146\146\151\143\x69\145\156\164\163"] = array(2 => new Math_BigInteger($this->_string_shift($ke, $iI), -256));
                return $OP;
        }
        FF:
        bQ:
    }
    function getSize()
    {
        return !isset($this->modulus) ? 0 : strlen($this->modulus->toBits());
    }
    function _start_element_handler($Rc, $zV, $fJ)
    {
        switch ($zV) {
            case "\115\117\104\125\x4c\x55\x53":
                $this->current =& $this->components["\155\157\x64\165\x6c\x75\x73"];
                goto s9;
            case "\x45\x58\120\117\116\x45\116\x54":
                $this->current =& $this->components["\160\165\142\154\151\143\x45\170\x70\157\x6e\145\x6e\164"];
                goto s9;
            case "\x50":
                $this->current =& $this->components["\x70\162\x69\155\145\163"][1];
                goto s9;
            case "\121":
                $this->current =& $this->components["\x70\x72\x69\x6d\x65\x73"][2];
                goto s9;
            case "\104\120":
                $this->current =& $this->components["\145\170\160\157\x6e\x65\x6e\164\163"][1];
                goto s9;
            case "\104\x51":
                $this->current =& $this->components["\145\x78\x70\157\x6e\x65\x6e\164\x73"][2];
                goto s9;
            case "\x49\x4e\x56\105\122\x53\105\x51":
                $this->current =& $this->components["\x63\x6f\x65\x66\x66\x69\143\151\x65\156\x74\163"][2];
                goto s9;
            case "\x44":
                $this->current =& $this->components["\x70\x72\x69\x76\141\x74\145\x45\x78\x70\157\x6e\x65\156\164"];
        }
        b1:
        s9:
        $this->current = '';
    }
    function _stop_element_handler($Rc, $zV)
    {
        if (!isset($this->current)) {
            goto iG;
        }
        $this->current = new Math_BigInteger(base64_decode($this->current), 256);
        unset($this->current);
        iG:
    }
    function _data_handler($Rc, $Ea)
    {
        if (!(!isset($this->current) || is_object($this->current))) {
            goto M8;
        }
        return;
        M8:
        $this->current .= trim($Ea);
    }
    function loadKey($O8, $Tf = false)
    {
        if (!(is_object($O8) && strtolower(get_class($O8)) == "\143\x72\171\x70\x74\x5f\x72\x73\x61")) {
            goto DT;
        }
        $this->privateKeyFormat = $O8->privateKeyFormat;
        $this->publicKeyFormat = $O8->publicKeyFormat;
        $this->k = $O8->k;
        $this->hLen = $O8->hLen;
        $this->sLen = $O8->sLen;
        $this->mgfHLen = $O8->mgfHLen;
        $this->encryptionMode = $O8->encryptionMode;
        $this->signatureMode = $O8->signatureMode;
        $this->password = $O8->password;
        $this->configFile = $O8->configFile;
        $this->comment = $O8->comment;
        if (!is_object($O8->hash)) {
            goto fu;
        }
        $this->hash = new Crypt_Hash($O8->hash->getHash());
        fu:
        if (!is_object($O8->mgfHash)) {
            goto c7;
        }
        $this->mgfHash = new Crypt_Hash($O8->mgfHash->getHash());
        c7:
        if (!is_object($O8->modulus)) {
            goto C7;
        }
        $this->modulus = $O8->modulus->copy();
        C7:
        if (!is_object($O8->exponent)) {
            goto Gd;
        }
        $this->exponent = $O8->exponent->copy();
        Gd:
        if (!is_object($O8->publicExponent)) {
            goto r3;
        }
        $this->publicExponent = $O8->publicExponent->copy();
        r3:
        $this->primes = array();
        $this->exponents = array();
        $this->coefficients = array();
        foreach ($this->primes as $VJ) {
            $this->primes[] = $VJ->copy();
            S9:
        }
        Iq:
        foreach ($this->exponents as $Z9) {
            $this->exponents[] = $Z9->copy();
            LH:
        }
        Ud:
        foreach ($this->coefficients as $uv) {
            $this->coefficients[] = $uv->copy();
            zA:
        }
        KQ:
        return true;
        DT:
        if ($Tf === false) {
            goto yH;
        }
        $OP = $this->_parseKey($O8, $Tf);
        goto nG;
        yH:
        $hc = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PRIVATE_FORMAT_PKCS1, CRYPT_RSA_PRIVATE_FORMAT_XML, CRYPT_RSA_PRIVATE_FORMAT_PUTTY, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        foreach ($hc as $Tf) {
            $OP = $this->_parseKey($O8, $Tf);
            if (!($OP !== false)) {
                goto Wg;
            }
            goto VJ;
            Wg:
            jA:
        }
        VJ:
        nG:
        if (!($OP === false)) {
            goto T0;
        }
        $this->comment = null;
        $this->modulus = null;
        $this->k = null;
        $this->exponent = null;
        $this->primes = null;
        $this->exponents = null;
        $this->coefficients = null;
        $this->publicExponent = null;
        return false;
        T0:
        if (!(isset($OP["\143\157\x6d\155\x65\x6e\x74"]) && $OP["\x63\x6f\155\x6d\145\x6e\x74"] !== false)) {
            goto jb;
        }
        $this->comment = $OP["\143\x6f\155\x6d\x65\x6e\164"];
        jb:
        $this->modulus = $OP["\x6d\157\144\x75\154\165\x73"];
        $this->k = strlen($this->modulus->toBytes());
        $this->exponent = isset($OP["\x70\162\151\x76\141\x74\x65\x45\x78\x70\x6f\156\x65\x6e\164"]) ? $OP["\x70\x72\x69\166\x61\164\x65\105\x78\x70\157\x6e\x65\x6e\164"] : $OP["\160\x75\142\154\151\143\x45\170\x70\x6f\x6e\145\x6e\164"];
        if (isset($OP["\x70\162\151\155\x65\163"])) {
            goto JX;
        }
        $this->primes = array();
        $this->exponents = array();
        $this->coefficients = array();
        $this->publicExponent = false;
        goto zg;
        JX:
        $this->primes = $OP["\160\x72\x69\155\145\x73"];
        $this->exponents = $OP["\x65\170\160\x6f\x6e\145\x6e\164\x73"];
        $this->coefficients = $OP["\143\x6f\x65\x66\146\151\143\x69\145\x6e\x74\x73"];
        $this->publicExponent = $OP["\160\165\x62\154\151\x63\x45\170\x70\157\156\145\156\x74"];
        zg:
        switch ($Tf) {
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                $this->setPublicKey();
                goto vi;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
                switch (true) {
                    case strpos($O8, "\55\x42\x45\107\x49\116\x20\120\125\x42\x4c\x49\103\x20\113\105\x59\55") !== false:
                    case strpos($O8, "\x2d\102\x45\x47\x49\x4e\x20\x52\x53\x41\x20\x50\125\102\x4c\x49\103\x20\x4b\x45\x59\x2d") !== false:
                        $this->setPublicKey();
                }
                jT:
                ZM:
        }
        ML:
        vi:
        return true;
    }
    function setPassword($r2 = false)
    {
        $this->password = $r2;
    }
    function setPublicKey($O8 = false, $Tf = false)
    {
        if (empty($this->publicExponent)) {
            goto Cj;
        }
        return false;
        Cj:
        if (!($O8 === false && !empty($this->modulus))) {
            goto q7;
        }
        $this->publicExponent = $this->exponent;
        return true;
        q7:
        if ($Tf === false) {
            goto Wm;
        }
        $OP = $this->_parseKey($O8, $Tf);
        goto Mv;
        Wm:
        $hc = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PUBLIC_FORMAT_PKCS1, CRYPT_RSA_PUBLIC_FORMAT_XML, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        foreach ($hc as $Tf) {
            $OP = $this->_parseKey($O8, $Tf);
            if (!($OP !== false)) {
                goto Ea;
            }
            goto Hv;
            Ea:
            wD:
        }
        Hv:
        Mv:
        if (!($OP === false)) {
            goto fJ;
        }
        return false;
        fJ:
        if (!(empty($this->modulus) || !$this->modulus->equals($OP["\x6d\x6f\x64\165\x6c\165\163"]))) {
            goto xr;
        }
        $this->modulus = $OP["\x6d\157\x64\x75\x6c\x75\x73"];
        $this->exponent = $this->publicExponent = $OP["\x70\165\142\154\x69\143\105\x78\160\x6f\x6e\x65\156\x74"];
        return true;
        xr:
        $this->publicExponent = $OP["\160\165\142\154\x69\x63\105\170\160\x6f\x6e\x65\x6e\164"];
        return true;
    }
    function setPrivateKey($O8 = false, $Tf = false)
    {
        if (!($O8 === false && !empty($this->publicExponent))) {
            goto Vv;
        }
        $this->publicExponent = false;
        return true;
        Vv:
        $T1 = new Crypt_RSA();
        if ($T1->loadKey($O8, $Tf)) {
            goto Jl;
        }
        return false;
        Jl:
        $T1->publicExponent = false;
        $this->loadKey($T1);
        return true;
    }
    function getPublicKey($Tf = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (!(empty($this->modulus) || empty($this->publicExponent))) {
            goto Is;
        }
        return false;
        Is:
        $DD = $this->publicKeyFormat;
        $this->publicKeyFormat = $Tf;
        $Ml = $this->_convertPublicKey($this->modulus, $this->publicExponent);
        $this->publicKeyFormat = $DD;
        return $Ml;
    }
    function getPublicKeyFingerprint($Ao = "\155\144\x35")
    {
        if (!(empty($this->modulus) || empty($this->publicExponent))) {
            goto hu;
        }
        return false;
        hu:
        $qH = $this->modulus->toBytes(true);
        $zB = $this->publicExponent->toBytes(true);
        $qx = pack("\x4e\141\x2a\x4e\141\52\x4e\141\x2a", strlen("\163\x73\x68\x2d\162\163\141"), "\x73\163\x68\x2d\x72\x73\x61", strlen($zB), $zB, strlen($qH), $qH);
        switch ($Ao) {
            case "\163\x68\x61\62\65\x36":
                $Y9 = new Crypt_Hash("\163\150\x61\x32\x35\x36");
                $q9 = base64_encode($Y9->hash($qx));
                return substr($q9, 0, strlen($q9) - 1);
            case "\x6d\x64\x35":
                return substr(chunk_split(md5($qx), 2, "\x3a"), 0, -1);
            default:
                return false;
        }
        O_:
        GF:
    }
    function getPrivateKey($Tf = CRYPT_RSA_PUBLIC_FORMAT_PKCS1)
    {
        if (!empty($this->primes)) {
            goto P8;
        }
        return false;
        P8:
        $DD = $this->privateKeyFormat;
        $this->privateKeyFormat = $Tf;
        $Ml = $this->_convertPrivateKey($this->modulus, $this->publicExponent, $this->exponent, $this->primes, $this->exponents, $this->coefficients);
        $this->privateKeyFormat = $DD;
        return $Ml;
    }
    function _getPrivatePublicKey($qp = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto Wz;
        }
        return false;
        Wz:
        $DD = $this->publicKeyFormat;
        $this->publicKeyFormat = $qp;
        $Ml = $this->_convertPublicKey($this->modulus, $this->exponent);
        $this->publicKeyFormat = $DD;
        return $Ml;
    }
    function __toString()
    {
        $O8 = $this->getPrivateKey($this->privateKeyFormat);
        if (!($O8 !== false)) {
            goto At;
        }
        return $O8;
        At:
        $O8 = $this->_getPrivatePublicKey($this->publicKeyFormat);
        return $O8 !== false ? $O8 : '';
    }
    function __clone()
    {
        $O8 = new Crypt_RSA();
        $O8->loadKey($this);
        return $O8;
    }
    function _generateMinMax($YP)
    {
        $IN = $YP >> 3;
        $b8 = str_repeat(chr(0), $IN);
        $nx = str_repeat(chr(0xff), $IN);
        $Mo = $YP & 7;
        if ($Mo) {
            goto bU;
        }
        $b8[0] = chr(0x80);
        goto qi;
        bU:
        $b8 = chr(1 << $Mo - 1) . $b8;
        $nx = chr((1 << $Mo) - 1) . $nx;
        qi:
        return array("\155\151\156" => new Math_BigInteger($b8, 256), "\x6d\141\x78" => new Math_BigInteger($nx, 256));
    }
    function _decodeLength(&$Ux)
    {
        $iI = ord($this->_string_shift($Ux));
        if (!($iI & 0x80)) {
            goto wA;
        }
        $iI &= 0x7f;
        $Ml = $this->_string_shift($Ux, $iI);
        list(, $iI) = unpack("\116", substr(str_pad($Ml, 4, chr(0), STR_PAD_LEFT), -4));
        wA:
        return $iI;
    }
    function _encodeLength($iI)
    {
        if (!($iI <= 0x7f)) {
            goto y8;
        }
        return chr($iI);
        y8:
        $Ml = ltrim(pack("\116", $iI), chr(0));
        return pack("\x43\x61\52", 0x80 | strlen($Ml), $Ml);
    }
    function _string_shift(&$Ux, $OE = 1)
    {
        $PA = substr($Ux, 0, $OE);
        $Ux = substr($Ux, $OE);
        return $PA;
    }
    function setPrivateKeyFormat($pK)
    {
        $this->privateKeyFormat = $pK;
    }
    function setPublicKeyFormat($pK)
    {
        $this->publicKeyFormat = $pK;
    }
    function setHash($Y9)
    {
        switch ($Y9) {
            case "\x6d\x64\62":
            case "\155\x64\x35":
            case "\163\x68\x61\x31":
            case "\x73\150\141\62\65\x36":
            case "\163\x68\x61\x33\70\x34":
            case "\x73\x68\x61\x35\x31\62":
                $this->hash = new Crypt_Hash($Y9);
                $this->hashName = $Y9;
                goto RA;
            default:
                $this->hash = new Crypt_Hash("\163\150\x61\61");
                $this->hashName = "\163\150\x61\61";
        }
        kw:
        RA:
        $this->hLen = $this->hash->getLength();
    }
    function setMGFHash($Y9)
    {
        switch ($Y9) {
            case "\155\x64\x32":
            case "\155\x64\65":
            case "\x73\x68\x61\x31":
            case "\x73\x68\141\x32\x35\x36":
            case "\x73\150\x61\x33\70\64":
            case "\163\150\141\x35\x31\x32":
                $this->mgfHash = new Crypt_Hash($Y9);
                goto Bz;
            default:
                $this->mgfHash = new Crypt_Hash("\163\150\141\61");
        }
        VF:
        Bz:
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function setSaltLength($Ak)
    {
        $this->sLen = $Ak;
    }
    function _i2osp($Rb, $rX)
    {
        $Rb = $Rb->toBytes();
        if (!(strlen($Rb) > $rX)) {
            goto Nh;
        }
        user_error("\111\x6e\x74\x65\147\145\162\40\x74\157\x6f\40\x6c\x61\162\147\x65");
        return false;
        Nh:
        return str_pad($Rb, $rX, chr(0), STR_PAD_LEFT);
    }
    function _os2ip($Rb)
    {
        return new Math_BigInteger($Rb, 256);
    }
    function _exponentiate($Rb)
    {
        switch (true) {
            case empty($this->primes):
            case $this->primes[1]->equals($this->zero):
            case empty($this->coefficients):
            case $this->coefficients[2]->equals($this->zero):
            case empty($this->exponents):
            case $this->exponents[1]->equals($this->zero):
                return $Rb->modPow($this->exponent, $this->modulus);
        }
        NI:
        KL:
        $YE = count($this->primes);
        if (defined("\103\122\x59\x50\x54\137\122\123\101\137\104\x49\123\101\102\114\105\x5f\x42\x4c\x49\116\x44\111\x4e\x47")) {
            goto eC;
        }
        $w9 = $this->primes[1];
        $uZ = 2;
        uQ:
        if (!($uZ <= $YE)) {
            goto zq;
        }
        if (!($w9->compare($this->primes[$uZ]) > 0)) {
            goto im;
        }
        $w9 = $this->primes[$uZ];
        im:
        NJ:
        $uZ++;
        goto uQ;
        zq:
        $is = new Math_BigInteger(1);
        $g5 = $is->random($is, $w9->subtract($is));
        $AC = array(1 => $this->_blind($Rb, $g5, 1), 2 => $this->_blind($Rb, $g5, 2));
        $Lz = $AC[1]->subtract($AC[2]);
        $Lz = $Lz->multiply($this->coefficients[2]);
        list(, $Lz) = $Lz->divide($this->primes[1]);
        $cA = $AC[2]->add($Lz->multiply($this->primes[2]));
        $g5 = $this->primes[1];
        $uZ = 3;
        f3:
        if (!($uZ <= $YE)) {
            goto Te;
        }
        $AC = $this->_blind($Rb, $g5, $uZ);
        $g5 = $g5->multiply($this->primes[$uZ - 1]);
        $Lz = $AC->subtract($cA);
        $Lz = $Lz->multiply($this->coefficients[$uZ]);
        list(, $Lz) = $Lz->divide($this->primes[$uZ]);
        $cA = $cA->add($g5->multiply($Lz));
        p5:
        $uZ++;
        goto f3;
        Te:
        goto fh;
        eC:
        $AC = array(1 => $Rb->modPow($this->exponents[1], $this->primes[1]), 2 => $Rb->modPow($this->exponents[2], $this->primes[2]));
        $Lz = $AC[1]->subtract($AC[2]);
        $Lz = $Lz->multiply($this->coefficients[2]);
        list(, $Lz) = $Lz->divide($this->primes[1]);
        $cA = $AC[2]->add($Lz->multiply($this->primes[2]));
        $g5 = $this->primes[1];
        $uZ = 3;
        Rf:
        if (!($uZ <= $YE)) {
            goto UP;
        }
        $AC = $Rb->modPow($this->exponents[$uZ], $this->primes[$uZ]);
        $g5 = $g5->multiply($this->primes[$uZ - 1]);
        $Lz = $AC->subtract($cA);
        $Lz = $Lz->multiply($this->coefficients[$uZ]);
        list(, $Lz) = $Lz->divide($this->primes[$uZ]);
        $cA = $cA->add($g5->multiply($Lz));
        jc:
        $uZ++;
        goto Rf;
        UP:
        fh:
        return $cA;
    }
    function _blind($Rb, $g5, $uZ)
    {
        $Rb = $Rb->multiply($g5->modPow($this->publicExponent, $this->primes[$uZ]));
        $Rb = $Rb->modPow($this->exponents[$uZ], $this->primes[$uZ]);
        $g5 = $g5->modInverse($this->primes[$uZ]);
        $Rb = $Rb->multiply($g5);
        list(, $Rb) = $Rb->divide($this->primes[$uZ]);
        return $Rb;
    }
    function _equals($Rb, $vN)
    {
        if (!(strlen($Rb) != strlen($vN))) {
            goto k0;
        }
        return false;
        k0:
        $al = 0;
        $uZ = 0;
        eX:
        if (!($uZ < strlen($Rb))) {
            goto M9;
        }
        $al |= ord($Rb[$uZ]) ^ ord($vN[$uZ]);
        Hf:
        $uZ++;
        goto eX;
        M9:
        return $al == 0;
    }
    function _rsaep($cA)
    {
        if (!($cA->compare($this->zero) < 0 || $cA->compare($this->modulus) > 0)) {
            goto WE;
        }
        user_error("\x4d\145\x73\x73\141\147\x65\40\x72\x65\160\162\x65\x73\x65\x6e\x74\x61\164\x69\x76\x65\x20\x6f\x75\x74\x20\157\146\x20\162\141\x6e\147\x65");
        return false;
        WE:
        return $this->_exponentiate($cA);
    }
    function _rsadp($GB)
    {
        if (!($GB->compare($this->zero) < 0 || $GB->compare($this->modulus) > 0)) {
            goto NO;
        }
        user_error("\103\151\x70\x68\x65\x72\164\x65\x78\x74\x20\162\x65\160\162\x65\x73\x65\156\x74\x61\164\151\x76\x65\x20\x6f\165\164\x20\x6f\x66\x20\162\141\156\147\145");
        return false;
        NO:
        return $this->_exponentiate($GB);
    }
    function _rsasp1($cA)
    {
        if (!($cA->compare($this->zero) < 0 || $cA->compare($this->modulus) > 0)) {
            goto Hj;
        }
        user_error("\115\x65\x73\163\141\x67\x65\40\162\145\x70\x72\145\163\145\156\164\141\164\x69\166\x65\40\x6f\165\164\x20\157\x66\x20\x72\141\x6e\x67\x65");
        return false;
        Hj:
        return $this->_exponentiate($cA);
    }
    function _rsavp1($rM)
    {
        if (!($rM->compare($this->zero) < 0 || $rM->compare($this->modulus) > 0)) {
            goto py;
        }
        user_error("\x53\x69\147\x6e\141\x74\165\x72\145\x20\x72\145\x70\x72\x65\x73\x65\156\164\141\x74\151\166\145\40\157\165\164\x20\157\146\x20\x72\x61\x6e\147\x65");
        return false;
        py:
        return $this->_exponentiate($rM);
    }
    function _mgf1($ql, $gl)
    {
        $I0 = '';
        $CA = ceil($gl / $this->mgfHLen);
        $uZ = 0;
        Oq:
        if (!($uZ < $CA)) {
            goto rk;
        }
        $GB = pack("\116", $uZ);
        $I0 .= $this->mgfHash->hash($ql . $GB);
        zt:
        $uZ++;
        goto Oq;
        rk:
        return substr($I0, 0, $gl);
    }
    function _rsaes_oaep_encrypt($cA, $XF = '')
    {
        $Ag = strlen($cA);
        if (!($Ag > $this->k - 2 * $this->hLen - 2)) {
            goto m5;
        }
        user_error("\115\145\x73\163\x61\x67\x65\x20\x74\x6f\157\40\154\x6f\x6e\147");
        return false;
        m5:
        $ND = $this->hash->hash($XF);
        $VP = str_repeat(chr(0), $this->k - $Ag - 2 * $this->hLen - 2);
        $wg = $ND . $VP . chr(1) . $cA;
        $Y6 = crypt_random_string($this->hLen);
        $f8 = $this->_mgf1($Y6, $this->k - $this->hLen - 1);
        $ns = $wg ^ $f8;
        $oK = $this->_mgf1($ns, $this->hLen);
        $o2 = $Y6 ^ $oK;
        $Bo = chr(0) . $o2 . $ns;
        $cA = $this->_os2ip($Bo);
        $GB = $this->_rsaep($cA);
        $GB = $this->_i2osp($GB, $this->k);
        return $GB;
    }
    function _rsaes_oaep_decrypt($GB, $XF = '')
    {
        if (!(strlen($GB) != $this->k || $this->k < 2 * $this->hLen + 2)) {
            goto tn;
        }
        user_error("\x44\x65\143\162\x79\160\x74\x69\157\x6e\x20\145\162\162\157\162");
        return false;
        tn:
        $GB = $this->_os2ip($GB);
        $cA = $this->_rsadp($GB);
        if (!($cA === false)) {
            goto q0;
        }
        user_error("\x44\145\143\162\171\160\164\x69\x6f\x6e\40\x65\x72\162\157\162");
        return false;
        q0:
        $Bo = $this->_i2osp($cA, $this->k);
        $ND = $this->hash->hash($XF);
        $vN = ord($Bo[0]);
        $o2 = substr($Bo, 1, $this->hLen);
        $ns = substr($Bo, $this->hLen + 1);
        $oK = $this->_mgf1($ns, $this->hLen);
        $Y6 = $o2 ^ $oK;
        $f8 = $this->_mgf1($Y6, $this->k - $this->hLen - 1);
        $wg = $ns ^ $f8;
        $tY = substr($wg, 0, $this->hLen);
        $cA = substr($wg, $this->hLen);
        if ($this->_equals($ND, $tY)) {
            goto fI;
        }
        user_error("\104\x65\x63\162\171\160\164\151\157\x6e\x20\x65\x72\x72\x6f\162");
        return false;
        fI:
        $cA = ltrim($cA, chr(0));
        if (!(ord($cA[0]) != 1)) {
            goto s_;
        }
        user_error("\x44\145\143\162\x79\x70\164\151\157\x6e\x20\x65\x72\162\157\x72");
        return false;
        s_:
        return substr($cA, 1);
    }
    function _raw_encrypt($cA)
    {
        $Ml = $this->_os2ip($cA);
        $Ml = $this->_rsaep($Ml);
        return $this->_i2osp($Ml, $this->k);
    }
    function _rsaes_pkcs1_v1_5_encrypt($cA)
    {
        $Ag = strlen($cA);
        if (!($Ag > $this->k - 11)) {
            goto sP;
        }
        user_error("\x4d\x65\163\x73\141\x67\x65\40\164\x6f\157\x20\154\157\156\x67");
        return false;
        sP:
        $Hs = $this->k - $Ag - 3;
        $VP = '';
        Bg:
        if (!(strlen($VP) != $Hs)) {
            goto R1;
        }
        $Ml = crypt_random_string($Hs - strlen($VP));
        $Ml = str_replace("\x0", '', $Ml);
        $VP .= $Ml;
        goto Bg;
        R1:
        $Tf = 2;
        if (!(defined("\103\122\x59\x50\124\x5f\122\123\x41\137\x50\113\103\123\61\65\137\103\117\x4d\x50\101\124") && (!isset($this->publicExponent) || $this->exponent !== $this->publicExponent))) {
            goto VP;
        }
        $Tf = 1;
        $VP = str_repeat("\xff", $Hs);
        VP:
        $Bo = chr(0) . chr($Tf) . $VP . chr(0) . $cA;
        $cA = $this->_os2ip($Bo);
        $GB = $this->_rsaep($cA);
        $GB = $this->_i2osp($GB, $this->k);
        return $GB;
    }
    function _rsaes_pkcs1_v1_5_decrypt($GB)
    {
        if (!(strlen($GB) != $this->k)) {
            goto Qo;
        }
        user_error("\x44\145\x63\x72\171\x70\x74\151\x6f\156\x20\145\162\x72\x6f\x72");
        return false;
        Qo:
        $GB = $this->_os2ip($GB);
        $cA = $this->_rsadp($GB);
        if (!($cA === false)) {
            goto Jx;
        }
        user_error("\104\x65\143\x72\171\x70\x74\x69\157\156\x20\x65\x72\x72\157\x72");
        return false;
        Jx:
        $Bo = $this->_i2osp($cA, $this->k);
        if (!(ord($Bo[0]) != 0 || ord($Bo[1]) > 2)) {
            goto HV;
        }
        user_error("\x44\145\x63\162\x79\160\x74\151\157\x6e\x20\145\162\162\157\x72");
        return false;
        HV:
        $VP = substr($Bo, 2, strpos($Bo, chr(0), 2) - 2);
        $cA = substr($Bo, strlen($VP) + 3);
        if (!(strlen($VP) < 8)) {
            goto sn;
        }
        user_error("\x44\145\x63\162\171\x70\x74\151\157\x6e\40\x65\162\162\x6f\162");
        return false;
        sn:
        return $cA;
    }
    function _emsa_pss_encode($cA, $Gh)
    {
        $XC = $Gh + 1 >> 3;
        $Ak = $this->sLen !== null ? $this->sLen : $this->hLen;
        $yi = $this->hash->hash($cA);
        if (!($XC < $this->hLen + $Ak + 2)) {
            goto CC;
        }
        user_error("\105\x6e\143\157\144\151\156\147\40\145\162\162\x6f\x72");
        return false;
        CC:
        $Lu = crypt_random_string($Ak);
        $F4 = "\x0\x0\x0\0\x0\0\0\x0" . $yi . $Lu;
        $Lz = $this->hash->hash($F4);
        $VP = str_repeat(chr(0), $XC - $Ak - $this->hLen - 2);
        $wg = $VP . chr(1) . $Lu;
        $f8 = $this->_mgf1($Lz, $XC - $this->hLen - 1);
        $ns = $wg ^ $f8;
        $ns[0] = ~chr(0xff << ($Gh & 7)) & $ns[0];
        $Bo = $ns . $Lz . chr(0xbc);
        return $Bo;
    }
    function _emsa_pss_verify($cA, $Bo, $Gh)
    {
        $XC = $Gh + 1 >> 3;
        $Ak = $this->sLen !== null ? $this->sLen : $this->hLen;
        $yi = $this->hash->hash($cA);
        if (!($XC < $this->hLen + $Ak + 2)) {
            goto Rc;
        }
        return false;
        Rc:
        if (!($Bo[strlen($Bo) - 1] != chr(0xbc))) {
            goto yJ;
        }
        return false;
        yJ:
        $ns = substr($Bo, 0, -$this->hLen - 1);
        $Lz = substr($Bo, -$this->hLen - 1, $this->hLen);
        $Ml = chr(0xff << ($Gh & 7));
        if (!((~$ns[0] & $Ml) != $Ml)) {
            goto SM;
        }
        return false;
        SM:
        $f8 = $this->_mgf1($Lz, $XC - $this->hLen - 1);
        $wg = $ns ^ $f8;
        $wg[0] = ~chr(0xff << ($Gh & 7)) & $wg[0];
        $Ml = $XC - $this->hLen - $Ak - 2;
        if (!(substr($wg, 0, $Ml) != str_repeat(chr(0), $Ml) || ord($wg[$Ml]) != 1)) {
            goto wo;
        }
        return false;
        wo:
        $Lu = substr($wg, $Ml + 1);
        $F4 = "\0\x0\0\0\x0\0\x0\0" . $yi . $Lu;
        $av = $this->hash->hash($F4);
        return $this->_equals($Lz, $av);
    }
    function _rsassa_pss_sign($cA)
    {
        $Bo = $this->_emsa_pss_encode($cA, 8 * $this->k - 1);
        $cA = $this->_os2ip($Bo);
        $rM = $this->_rsasp1($cA);
        $rM = $this->_i2osp($rM, $this->k);
        return $rM;
    }
    function _rsassa_pss_verify($cA, $rM)
    {
        if (!(strlen($rM) != $this->k)) {
            goto Ny;
        }
        user_error("\x49\156\x76\141\154\x69\x64\40\163\151\x67\x6e\x61\164\x75\x72\145");
        return false;
        Ny:
        $EG = 8 * $this->k;
        $pr = $this->_os2ip($rM);
        $F4 = $this->_rsavp1($pr);
        if (!($F4 === false)) {
            goto oy;
        }
        user_error("\111\156\x76\141\x6c\151\144\40\163\x69\x67\156\141\164\165\162\145");
        return false;
        oy:
        $Bo = $this->_i2osp($F4, $EG >> 3);
        if (!($Bo === false)) {
            goto jl;
        }
        user_error("\x49\156\x76\141\154\x69\x64\x20\163\x69\147\x6e\141\x74\165\162\x65");
        return false;
        jl:
        return $this->_emsa_pss_verify($cA, $Bo, $EG - 1);
    }
    function _emsa_pkcs1_v1_5_encode($cA, $XC)
    {
        $Lz = $this->hash->hash($cA);
        if (!($Lz === false)) {
            goto X5;
        }
        return false;
        X5:
        switch ($this->hashName) {
            case "\155\x64\62":
                $I0 = pack("\x48\52", "\x33\60\62\60\63\x30\60\143\60\66\60\x38\x32\x61\70\x36\64\x38\70\x36\146\x37\x30\x64\60\x32\60\62\x30\65\60\60\60\64\x31\60");
                goto QC;
            case "\x6d\144\x35":
                $I0 = pack("\110\52", "\63\x30\62\x30\x33\x30\60\x63\x30\x36\x30\x38\x32\x61\x38\66\x34\70\x38\x36\146\x37\60\x64\60\62\60\x35\60\x35\60\x30\x30\64\61\x30");
                goto QC;
            case "\x73\x68\141\x31":
                $I0 = pack("\110\52", "\63\x30\62\61\x33\x30\x30\71\60\66\x30\65\x32\142\x30\145\60\x33\60\x32\x31\141\60\x35\x30\x30\60\x34\x31\64");
                goto QC;
            case "\163\x68\x61\62\65\66":
                $I0 = pack("\x48\52", "\63\x30\x33\61\x33\60\60\x64\60\x36\60\x39\x36\x30\x38\66\64\70\x30\x31\x36\65\x30\63\60\64\60\62\x30\61\60\65\60\60\60\64\x32\60");
                goto QC;
            case "\163\x68\141\x33\70\64":
                $I0 = pack("\110\x2a", "\x33\60\x34\x31\x33\x30\x30\144\60\66\60\71\x36\60\x38\66\64\x38\x30\61\x36\65\x30\x33\60\64\x30\x32\x30\62\x30\x35\x30\60\60\64\x33\x30");
                goto QC;
            case "\163\x68\x61\x35\x31\62":
                $I0 = pack("\x48\x2a", "\x33\x30\65\x31\63\x30\x30\144\x30\x36\x30\x39\x36\x30\x38\66\x34\70\x30\61\x36\65\60\x33\60\64\60\62\60\x33\60\65\x30\x30\x30\x34\64\60");
        }
        gw:
        QC:
        $I0 .= $Lz;
        $CH = strlen($I0);
        if (!($XC < $CH + 11)) {
            goto gS;
        }
        user_error("\x49\156\164\x65\x6e\x64\x65\144\40\145\156\x63\x6f\x64\145\144\40\155\x65\x73\x73\x61\x67\145\40\x6c\x65\156\147\x74\150\x20\x74\x6f\157\x20\x73\150\157\162\164");
        return false;
        gS:
        $VP = str_repeat(chr(0xff), $XC - $CH - 3);
        $Bo = "\0\x1{$VP}\x0{$I0}";
        return $Bo;
    }
    function _rsassa_pkcs1_v1_5_sign($cA)
    {
        $Bo = $this->_emsa_pkcs1_v1_5_encode($cA, $this->k);
        if (!($Bo === false)) {
            goto f5;
        }
        user_error("\122\123\101\40\x6d\x6f\x64\165\154\165\x73\40\x74\157\x6f\x20\163\x68\157\x72\164");
        return false;
        f5:
        $cA = $this->_os2ip($Bo);
        $rM = $this->_rsasp1($cA);
        $rM = $this->_i2osp($rM, $this->k);
        return $rM;
    }
    function _rsassa_pkcs1_v1_5_verify($cA, $rM)
    {
        if (!(strlen($rM) != $this->k)) {
            goto Ur;
        }
        user_error("\111\x6e\166\x61\x6c\151\144\x20\x73\x69\147\x6e\x61\x74\165\x72\145");
        return false;
        Ur:
        $rM = $this->_os2ip($rM);
        $F4 = $this->_rsavp1($rM);
        if (!($F4 === false)) {
            goto uy;
        }
        user_error("\x49\156\x76\x61\154\x69\x64\40\x73\x69\147\156\x61\x74\x75\x72\145");
        return false;
        uy:
        $Bo = $this->_i2osp($F4, $this->k);
        if (!($Bo === false)) {
            goto zT;
        }
        user_error("\x49\x6e\166\141\154\151\144\40\x73\151\x67\156\141\x74\x75\162\x65");
        return false;
        zT:
        $UG = $this->_emsa_pkcs1_v1_5_encode($cA, $this->k);
        if (!($UG === false)) {
            goto RF;
        }
        user_error("\122\123\x41\40\x6d\x6f\144\165\x6c\165\x73\40\164\157\157\40\163\150\157\x72\x74");
        return false;
        RF:
        return $this->_equals($Bo, $UG);
    }
    function setEncryptionMode($qp)
    {
        $this->encryptionMode = $qp;
    }
    function setSignatureMode($qp)
    {
        $this->signatureMode = $qp;
    }
    function setComment($a9)
    {
        $this->comment = $a9;
    }
    function getComment()
    {
        return $this->comment;
    }
    function encrypt($Ys)
    {
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $Ys = str_split($Ys, $this->k);
                $le = '';
                foreach ($Ys as $cA) {
                    $le .= $this->_raw_encrypt($cA);
                    Jy:
                }
                Oo:
                return $le;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $iI = $this->k - 11;
                if (!($iI <= 0)) {
                    goto ik;
                }
                return false;
                ik:
                $Ys = str_split($Ys, $iI);
                $le = '';
                foreach ($Ys as $cA) {
                    $le .= $this->_rsaes_pkcs1_v1_5_encrypt($cA);
                    lY:
                }
                GG:
                return $le;
            default:
                $iI = $this->k - 2 * $this->hLen - 2;
                if (!($iI <= 0)) {
                    goto Zt;
                }
                return false;
                Zt:
                $Ys = str_split($Ys, $iI);
                $le = '';
                foreach ($Ys as $cA) {
                    $le .= $this->_rsaes_oaep_encrypt($cA);
                    kD:
                }
                ih:
                return $le;
        }
        KP:
        N1:
    }
    function decrypt($le)
    {
        if (!($this->k <= 0)) {
            goto qI;
        }
        return false;
        qI:
        $le = str_split($le, $this->k);
        $le[count($le) - 1] = str_pad($le[count($le) - 1], $this->k, chr(0), STR_PAD_LEFT);
        $Ys = '';
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $vf = "\x5f\162\x61\x77\137\x65\x6e\x63\162\171\160\x74";
                goto WH;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $vf = "\x5f\x72\x73\141\145\x73\x5f\160\x6b\x63\x73\x31\x5f\x76\x31\x5f\65\x5f\x64\145\x63\162\171\160\164";
                goto WH;
            default:
                $vf = "\137\162\163\141\x65\163\x5f\157\x61\x65\160\137\144\145\x63\x72\x79\x70\x74";
        }
        Fr:
        WH:
        foreach ($le as $GB) {
            $Ml = $this->{$vf}($GB);
            if (!($Ml === false)) {
                goto W_;
            }
            return false;
            W_:
            $Ys .= $Ml;
            Yu:
        }
        R8:
        return $Ys;
    }
    function sign($V6)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto Ya;
        }
        return false;
        Ya:
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_sign($V6);
            default:
                return $this->_rsassa_pss_sign($V6);
        }
        iU:
        j3:
    }
    function verify($V6, $SK)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto RL;
        }
        return false;
        RL:
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_verify($V6, $SK);
            default:
                return $this->_rsassa_pss_verify($V6, $SK);
        }
        DX:
        Q1:
    }
    function _extractBER($W0)
    {
        $Ml = preg_replace("\43\x2e\x2a\77\x5e\55\53\x5b\136\55\x5d\x2b\x2d\53\x5b\134\x72\134\x6e\x20\135\52\x24\x23\155\x73", '', $W0, 1);
        $Ml = preg_replace("\43\x2d\x2b\133\136\55\135\53\55\x2b\x23", '', $Ml);
        $Ml = str_replace(array("\15", "\12", "\40"), '', $Ml);
        $Ml = preg_match("\43\136\133\141\55\x7a\x41\55\132\x5c\144\57\x2b\135\52\x3d\173\x30\54\x32\x7d\44\x23", $Ml) ? base64_decode($Ml) : false;
        return $Ml != false ? $Ml : $W0;
    }
}
