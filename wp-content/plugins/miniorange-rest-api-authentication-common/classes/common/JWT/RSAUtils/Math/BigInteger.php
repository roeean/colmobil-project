<?php


namespace MoRESTAPI;

if (defined("\115\x41\x54\110\x5f\102\x49\x47\111\x4e\124\105\x47\105\x52\137\x4d\117\x4e\124\107\117\115\105\x52\x59")) {
    goto yr;
}
define("\115\101\x54\x48\137\x42\111\x47\111\116\x54\x45\x47\105\x52\x5f\115\117\x4e\x54\107\x4f\115\105\122\x59", 0);
yr:
if (defined("\x4d\101\x54\x48\x5f\x42\x49\107\111\x4e\x54\105\107\x45\x52\137\x42\101\x52\122\105\x54\x54")) {
    goto Ei;
}
define("\x4d\x41\x54\x48\137\x42\x49\x47\111\x4e\124\105\x47\x45\122\137\x42\x41\122\x52\105\124\124", 1);
Ei:
if (defined("\x4d\x41\124\110\x5f\x42\111\x47\x49\116\x54\105\x47\105\122\x5f\x50\x4f\x57\105\122\x4f\106\x32")) {
    goto WF;
}
define("\115\101\124\x48\x5f\102\x49\107\111\x4e\124\x45\107\x45\x52\137\x50\117\127\x45\x52\x4f\x46\62", 2);
WF:
if (defined("\115\x41\124\x48\137\x42\111\107\111\116\124\105\107\105\122\x5f\103\114\x41\x53\x53\x49\x43")) {
    goto Ly;
}
define("\x4d\101\x54\x48\x5f\x42\111\107\111\116\124\x45\x47\x45\122\137\103\114\101\x53\123\x49\103", 3);
Ly:
if (defined("\x4d\x41\124\x48\137\102\111\x47\x49\116\x54\105\107\x45\x52\137\116\x4f\116\x45")) {
    goto bM;
}
define("\115\x41\124\x48\137\102\111\107\111\116\x54\x45\x47\x45\122\137\x4e\117\116\x45", 4);
bM:
if (defined("\115\x41\124\x48\137\x42\111\x47\x49\x4e\124\x45\107\x45\x52\137\126\x41\114\125\x45")) {
    goto T3;
}
define("\x4d\101\x54\110\137\x42\x49\107\x49\x4e\x54\105\107\x45\122\137\126\101\114\125\105", 0);
T3:
if (defined("\115\x41\x54\110\x5f\102\111\107\x49\x4e\124\105\x47\105\122\x5f\x53\x49\x47\116")) {
    goto sF;
}
define("\x4d\x41\124\110\x5f\x42\111\107\111\x4e\124\105\107\x45\122\137\123\x49\x47\116", 1);
sF:
if (defined("\115\101\x54\110\x5f\102\x49\x47\x49\116\x54\105\107\x45\122\x5f\126\x41\x52\111\101\102\114\105")) {
    goto Ir;
}
define("\x4d\x41\x54\110\137\x42\111\107\x49\x4e\124\x45\107\x45\x52\x5f\126\x41\x52\111\x41\x42\x4c\105", 0);
Ir:
if (defined("\x4d\101\124\110\x5f\102\111\107\x49\x4e\x54\105\107\x45\x52\137\104\101\124\101")) {
    goto It;
}
define("\115\101\124\110\137\102\111\107\x49\116\x54\105\x47\x45\122\137\104\x41\124\101", 1);
It:
if (defined("\x4d\101\x54\110\x5f\102\x49\x47\x49\x4e\x54\105\107\x45\122\137\115\117\104\105\137\x49\116\124\105\122\x4e\101\x4c")) {
    goto ut;
}
define("\x4d\101\124\110\x5f\102\111\107\x49\116\124\x45\107\x45\x52\x5f\115\117\x44\x45\x5f\x49\x4e\x54\105\122\116\101\x4c", 1);
ut:
if (defined("\115\101\x54\110\137\x42\111\x47\x49\116\x54\x45\x47\x45\122\137\115\117\x44\x45\137\102\x43\115\x41\x54\x48")) {
    goto QH;
}
define("\115\101\x54\x48\x5f\102\111\x47\111\116\124\x45\x47\105\122\x5f\x4d\x4f\x44\x45\x5f\102\x43\115\x41\124\110", 2);
QH:
if (defined("\x4d\101\124\x48\137\x42\x49\107\111\116\124\x45\107\105\x52\137\x4d\x4f\104\x45\137\107\115\x50")) {
    goto Pm;
}
define("\x4d\x41\x54\110\x5f\102\x49\107\x49\116\x54\105\x47\105\122\137\x4d\x4f\104\105\137\x47\x4d\x50", 3);
Pm:
if (defined("\115\x41\124\110\137\x42\x49\x47\x49\x4e\x54\105\107\x45\x52\x5f\113\x41\x52\x41\x54\123\x55\102\101\x5f\103\x55\x54\x4f\106\x46")) {
    goto xN;
}
define("\x4d\101\124\x48\137\x42\x49\x47\111\x4e\124\105\x47\105\122\x5f\x4b\x41\122\101\x54\123\125\x42\x41\137\103\125\x54\x4f\x46\106", 25);
xN:
class Math_BigInteger
{
    var $value;
    var $is_negative = false;
    var $precision = -1;
    var $bitmask = false;
    var $hex;
    function __construct($Rb = 0, $q9 = 10)
    {
        if (defined("\x4d\x41\124\110\137\x42\111\x47\x49\x4e\x54\105\x47\x45\122\137\x4d\117\x44\105")) {
            goto Ff;
        }
        switch (true) {
            case extension_loaded("\147\155\x70"):
                define("\115\101\124\110\137\x42\111\107\x49\116\x54\x45\x47\105\122\x5f\115\117\x44\x45", MATH_BIGINTEGER_MODE_GMP);
                goto uk;
            case extension_loaded("\x62\143\155\x61\164\150"):
                define("\x4d\x41\x54\110\x5f\102\111\x47\x49\116\x54\x45\x47\x45\x52\137\x4d\x4f\x44\105", MATH_BIGINTEGER_MODE_BCMATH);
                goto uk;
            default:
                define("\115\101\124\110\137\x42\111\107\111\x4e\124\105\x47\105\x52\x5f\x4d\117\x44\105", MATH_BIGINTEGER_MODE_INTERNAL);
        }
        Sp:
        uk:
        Ff:
        if (!(extension_loaded("\x6f\160\x65\156\163\x73\x6c") && !defined("\x4d\101\124\x48\x5f\102\x49\107\111\x4e\124\105\107\x45\x52\x5f\117\120\105\116\x53\x53\114\137\x44\x49\x53\x41\102\x4c\105") && !defined("\x4d\x41\124\x48\x5f\102\x49\x47\x49\116\x54\105\x47\x45\x52\x5f\117\x50\105\116\x53\x53\114\x5f\105\x4e\x41\x42\x4c\x45\x44"))) {
            goto GV;
        }
        ob_start();
        @phpinfo();
        $OK = ob_get_contents();
        ob_end_clean();
        preg_match_all("\43\x4f\160\145\156\123\x53\114\40\50\110\x65\x61\144\145\x72\174\114\151\142\x72\x61\x72\x79\51\40\126\x65\x72\x73\x69\157\156\50\56\52\x29\43\x69\x6d", $OK, $cM);
        $Xk = array();
        if (empty($cM[1])) {
            goto d4;
        }
        $uZ = 0;
        fb:
        if (!($uZ < count($cM[1]))) {
            goto ms;
        }
        $Hc = trim(str_replace("\75\x3e", '', strip_tags($cM[2][$uZ])));
        if (!preg_match("\57\50\x5c\x64\x2b\x5c\56\x5c\144\x2b\x5c\56\134\144\x2b\51\x2f\151", $Hc, $cA)) {
            goto zj;
        }
        $Xk[$cM[1][$uZ]] = $cA[0];
        goto i8;
        zj:
        $Xk[$cM[1][$uZ]] = $Hc;
        i8:
        k1:
        $uZ++;
        goto fb;
        ms:
        d4:
        switch (true) {
            case !isset($Xk["\x48\145\141\x64\x65\162"]):
            case !isset($Xk["\114\151\x62\x72\141\162\x79"]):
            case $Xk["\x48\145\x61\144\x65\x72"] == $Xk["\114\151\x62\162\141\162\x79"]:
            case version_compare($Xk["\110\x65\x61\144\145\x72"], "\x31\56\60\56\60") >= 0 && version_compare($Xk["\114\x69\142\162\141\x72\x79"], "\x31\56\x30\56\60") >= 0:
                define("\x4d\101\x54\110\x5f\x42\x49\107\x49\116\x54\x45\x47\x45\x52\x5f\x4f\x50\105\116\123\x53\114\x5f\105\116\x41\x42\114\105\x44", true);
                goto CS;
            default:
                define("\115\101\124\110\137\x42\111\107\x49\116\124\105\x47\105\122\137\117\x50\x45\x4e\123\123\x4c\x5f\x44\111\123\101\102\114\105", true);
        }
        hg:
        CS:
        GV:
        if (defined("\x50\x48\120\137\x49\116\124\137\x53\111\x5a\105")) {
            goto Wd;
        }
        define("\120\110\x50\137\x49\116\124\137\123\111\132\x45", 4);
        Wd:
        if (!(!defined("\x4d\101\x54\110\137\102\111\x47\x49\x4e\124\105\107\105\122\137\102\x41\123\x45") && MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_INTERNAL)) {
            goto wI;
        }
        switch (PHP_INT_SIZE) {
            case 8:
                define("\x4d\101\x54\x48\137\x42\111\x47\x49\116\124\105\x47\x45\x52\x5f\x42\x41\x53\105", 31);
                define("\115\x41\124\110\137\102\111\107\111\116\124\x45\x47\105\x52\x5f\x42\x41\123\x45\137\106\125\114\x4c", 0x80000000);
                define("\x4d\101\124\110\137\102\x49\x47\x49\x4e\124\105\x47\x45\122\x5f\115\101\x58\137\x44\x49\x47\111\x54", 0x7fffffff);
                define("\115\x41\124\110\x5f\102\x49\107\111\x4e\x54\105\x47\x45\x52\x5f\115\123\102", 0x40000000);
                define("\x4d\101\x54\x48\137\102\111\x47\x49\116\124\105\107\x45\122\x5f\x4d\101\x58\x31\60", 1000000000);
                define("\x4d\101\x54\110\137\102\111\x47\x49\x4e\124\x45\107\105\122\x5f\x4d\x41\130\61\x30\x5f\114\105\116", 9);
                define("\x4d\101\124\110\x5f\102\111\107\111\116\x54\x45\x47\x45\122\x5f\115\101\130\137\104\111\x47\111\x54\x32", pow(2, 62));
                goto Xl;
            default:
                define("\115\101\x54\110\x5f\x42\111\x47\111\x4e\124\105\x47\x45\x52\x5f\102\101\123\x45", 26);
                define("\x4d\x41\x54\x48\137\102\x49\107\x49\116\x54\x45\107\x45\122\x5f\102\x41\123\x45\x5f\106\125\114\114", 0x4000000);
                define("\115\101\124\x48\137\102\x49\x47\111\116\124\105\107\105\122\137\x4d\101\130\137\104\x49\107\111\x54", 0x3ffffff);
                define("\115\x41\124\x48\x5f\x42\x49\107\111\x4e\x54\105\x47\105\122\x5f\115\123\102", 0x2000000);
                define("\x4d\x41\x54\110\137\102\x49\x47\x49\116\x54\x45\x47\x45\122\137\x4d\101\130\61\60", 10000000);
                define("\115\101\x54\x48\x5f\102\x49\x47\111\116\x54\105\x47\105\122\137\115\x41\x58\x31\60\137\x4c\x45\x4e", 7);
                define("\115\x41\124\x48\x5f\102\x49\107\x49\116\x54\x45\x47\x45\x52\x5f\x4d\x41\x58\137\104\x49\x47\111\124\x32", pow(2, 52));
        }
        Sl:
        Xl:
        wI:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                switch (true) {
                    case is_resource($Rb) && get_resource_type($Rb) == "\107\115\120\40\151\156\x74\x65\x67\145\x72":
                    case is_object($Rb) && get_class($Rb) == "\107\x4d\x50":
                        $this->value = $Rb;
                        return;
                }
                Ne:
                X0:
                $this->value = gmp_init(0);
                goto qo;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $this->value = "\60";
                goto qo;
            default:
                $this->value = array();
        }
        CT:
        qo:
        if (!(empty($Rb) && (abs($q9) != 256 || $Rb !== "\60"))) {
            goto mn;
        }
        return;
        mn:
        switch ($q9) {
            case -256:
                if (!(ord($Rb[0]) & 0x80)) {
                    goto tc;
                }
                $Rb = ~$Rb;
                $this->is_negative = true;
                tc:
            case 256:
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = function_exists("\147\155\160\137\x69\155\160\157\x72\x74") ? gmp_import($Rb) : gmp_init("\x30\170" . bin2hex($Rb));
                        if (!$this->is_negative) {
                            goto nM;
                        }
                        $this->value = gmp_neg($this->value);
                        nM:
                        goto r9;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $s2 = strlen($Rb) + 3 & 0xfffffffc;
                        $Rb = str_pad($Rb, $s2, chr(0), STR_PAD_LEFT);
                        $uZ = 0;
                        Aq:
                        if (!($uZ < $s2)) {
                            goto a2;
                        }
                        $this->value = bcmul($this->value, "\x34\x32\x39\64\71\66\x37\62\x39\66", 0);
                        $this->value = bcadd($this->value, 0x1000000 * ord($Rb[$uZ]) + (ord($Rb[$uZ + 1]) << 16 | ord($Rb[$uZ + 2]) << 8 | ord($Rb[$uZ + 3])), 0);
                        wG:
                        $uZ += 4;
                        goto Aq;
                        a2:
                        if (!$this->is_negative) {
                            goto ap;
                        }
                        $this->value = "\55" . $this->value;
                        ap:
                        goto r9;
                    default:
                        N7:
                        if (!strlen($Rb)) {
                            goto jS;
                        }
                        $this->value[] = $this->_bytes2int($this->_base256_rshift($Rb, MATH_BIGINTEGER_BASE));
                        goto N7;
                        jS:
                }
                O8:
                r9:
                if (!$this->is_negative) {
                    goto jj;
                }
                if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL)) {
                    goto cM;
                }
                $this->is_negative = false;
                cM:
                $Ml = $this->add(new Math_BigInteger("\55\61"));
                $this->value = $Ml->value;
                jj:
                goto BZ;
            case 16:
            case -16:
                if (!($q9 > 0 && $Rb[0] == "\55")) {
                    goto iE;
                }
                $this->is_negative = true;
                $Rb = substr($Rb, 1);
                iE:
                $Rb = preg_replace("\43\136\50\x3f\72\x30\170\x29\x3f\x28\133\101\55\106\141\55\x66\60\55\71\x5d\52\x29\56\52\x23", "\44\61", $Rb);
                $Ck = false;
                if (!($q9 < 0 && hexdec($Rb[0]) >= 8)) {
                    goto LD;
                }
                $this->is_negative = $Ck = true;
                $Rb = bin2hex(~pack("\110\x2a", $Rb));
                LD:
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $Ml = $this->is_negative ? "\55\60\170" . $Rb : "\x30\170" . $Rb;
                        $this->value = gmp_init($Ml);
                        $this->is_negative = false;
                        goto hG;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $Rb = strlen($Rb) & 1 ? "\60" . $Rb : $Rb;
                        $Ml = new Math_BigInteger(pack("\x48\52", $Rb), 256);
                        $this->value = $this->is_negative ? "\x2d" . $Ml->value : $Ml->value;
                        $this->is_negative = false;
                        goto hG;
                    default:
                        $Rb = strlen($Rb) & 1 ? "\x30" . $Rb : $Rb;
                        $Ml = new Math_BigInteger(pack("\x48\x2a", $Rb), 256);
                        $this->value = $Ml->value;
                }
                VO:
                hG:
                if (!$Ck) {
                    goto uK;
                }
                $Ml = $this->add(new Math_BigInteger("\55\x31"));
                $this->value = $Ml->value;
                uK:
                goto BZ;
            case 10:
            case -10:
                $Rb = preg_replace("\43\50\x3f\74\41\x5e\x29\x28\x3f\x3a\x2d\x29\56\x2a\x7c\x28\x3f\74\75\136\174\55\x29\60\52\x7c\133\x5e\x2d\60\x2d\x39\x5d\x2e\52\x23", '', $Rb);
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = gmp_init($Rb);
                        goto cl;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $this->value = $Rb === "\55" ? "\x30" : (string) $Rb;
                        goto cl;
                    default:
                        $Ml = new Math_BigInteger();
                        $BO = new Math_BigInteger();
                        $BO->value = array(MATH_BIGINTEGER_MAX10);
                        if (!($Rb[0] == "\55")) {
                            goto mN;
                        }
                        $this->is_negative = true;
                        $Rb = substr($Rb, 1);
                        mN:
                        $Rb = str_pad($Rb, strlen($Rb) + (MATH_BIGINTEGER_MAX10_LEN - 1) * strlen($Rb) % MATH_BIGINTEGER_MAX10_LEN, 0, STR_PAD_LEFT);
                        Ub:
                        if (!strlen($Rb)) {
                            goto Zo;
                        }
                        $Ml = $Ml->multiply($BO);
                        $Ml = $Ml->add(new Math_BigInteger($this->_int2bytes(substr($Rb, 0, MATH_BIGINTEGER_MAX10_LEN)), 256));
                        $Rb = substr($Rb, MATH_BIGINTEGER_MAX10_LEN);
                        goto Ub;
                        Zo:
                        $this->value = $Ml->value;
                }
                X4:
                cl:
                goto BZ;
            case 2:
            case -2:
                if (!($q9 > 0 && $Rb[0] == "\55")) {
                    goto w3;
                }
                $this->is_negative = true;
                $Rb = substr($Rb, 1);
                w3:
                $Rb = preg_replace("\43\136\50\133\x30\61\x5d\52\51\x2e\52\x23", "\44\61", $Rb);
                $Rb = str_pad($Rb, strlen($Rb) + 3 * strlen($Rb) % 4, 0, STR_PAD_LEFT);
                $W0 = "\x30\x78";
                T4:
                if (!strlen($Rb)) {
                    goto t9;
                }
                $wM = substr($Rb, 0, 4);
                $W0 .= dechex(bindec($wM));
                $Rb = substr($Rb, 4);
                goto T4;
                t9:
                if (!$this->is_negative) {
                    goto f_;
                }
                $W0 = "\x2d" . $W0;
                f_:
                $Ml = new Math_BigInteger($W0, 8 * $q9);
                $this->value = $Ml->value;
                $this->is_negative = $Ml->is_negative;
                goto BZ;
            default:
        }
        Gq:
        BZ:
    }
    function Math_BigInteger($Rb = 0, $q9 = 10)
    {
        $this->__construct($Rb, $q9);
    }
    function toBytes($mQ = false)
    {
        if (!$mQ) {
            goto mQ;
        }
        $PP = $this->compare(new Math_BigInteger());
        if (!($PP == 0)) {
            goto zb;
        }
        return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
        zb:
        $Ml = $PP < 0 ? $this->add(new Math_BigInteger(1)) : $this->copy();
        $IN = $Ml->toBytes();
        if (!empty($IN)) {
            goto tG;
        }
        $IN = chr(0);
        tG:
        if (!(ord($IN[0]) & 0x80)) {
            goto GW;
        }
        $IN = chr(0) . $IN;
        GW:
        return $PP < 0 ? ~$IN : $IN;
        mQ:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (!(gmp_cmp($this->value, gmp_init(0)) == 0)) {
                    goto cZ;
                }
                return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
                cZ:
                if (function_exists("\x67\155\x70\x5f\x65\170\160\x6f\162\x74")) {
                    goto SG;
                }
                $Ml = gmp_strval(gmp_abs($this->value), 16);
                $Ml = strlen($Ml) & 1 ? "\60" . $Ml : $Ml;
                $Ml = pack("\110\52", $Ml);
                goto sg;
                SG:
                $Ml = gmp_export($this->value);
                sg:
                return $this->precision > 0 ? substr(str_pad($Ml, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($Ml, chr(0));
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\x30")) {
                    goto II;
                }
                return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
                II:
                $pj = '';
                $eG = $this->value;
                if (!($eG[0] == "\x2d")) {
                    goto HA;
                }
                $eG = substr($eG, 1);
                HA:
                Ju:
                if (!(bccomp($eG, "\60", 0) > 0)) {
                    goto KI;
                }
                $Ml = bcmod($eG, "\x31\x36\x37\x37\x37\x32\x31\x36");
                $pj = chr($Ml >> 16) . chr($Ml >> 8) . chr($Ml) . $pj;
                $eG = bcdiv($eG, "\x31\66\67\67\67\x32\61\x36", 0);
                goto Ju;
                KI:
                return $this->precision > 0 ? substr(str_pad($pj, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($pj, chr(0));
        }
        IK:
        tg:
        if (count($this->value)) {
            goto Gm;
        }
        return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
        Gm:
        $al = $this->_int2bytes($this->value[count($this->value) - 1]);
        $Ml = $this->copy();
        $uZ = count($Ml->value) - 2;
        Zv:
        if (!($uZ >= 0)) {
            goto Jt;
        }
        $Ml->_base256_lshift($al, MATH_BIGINTEGER_BASE);
        $al = $al | str_pad($Ml->_int2bytes($Ml->value[$uZ]), strlen($al), chr(0), STR_PAD_LEFT);
        Xb:
        --$uZ;
        goto Zv;
        Jt:
        return $this->precision > 0 ? str_pad(substr($al, -($this->precision + 7 >> 3)), $this->precision + 7 >> 3, chr(0), STR_PAD_LEFT) : $al;
    }
    function toHex($mQ = false)
    {
        return bin2hex($this->toBytes($mQ));
    }
    function toBits($mQ = false)
    {
        $P6 = $this->toHex($mQ);
        $YP = '';
        $uZ = strlen($P6) - 8;
        $zJ = strlen($P6) & 7;
        OD:
        if (!($uZ >= $zJ)) {
            goto oF;
        }
        $YP = str_pad(decbin(hexdec(substr($P6, $uZ, 8))), 32, "\x30", STR_PAD_LEFT) . $YP;
        RD:
        $uZ -= 8;
        goto OD;
        oF:
        if (!$zJ) {
            goto o5;
        }
        $YP = str_pad(decbin(hexdec(substr($P6, 0, $zJ))), 8, "\60", STR_PAD_LEFT) . $YP;
        o5:
        $al = $this->precision > 0 ? substr($YP, -$this->precision) : ltrim($YP, "\60");
        if (!($mQ && $this->compare(new Math_BigInteger()) > 0 && $this->precision <= 0)) {
            goto RK;
        }
        return "\60" . $al;
        RK:
        return $al;
    }
    function toString()
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_strval($this->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\60")) {
                    goto om;
                }
                return "\60";
                om:
                return ltrim($this->value, "\60");
        }
        K8:
        w2:
        if (count($this->value)) {
            goto jm;
        }
        return "\60";
        jm:
        $Ml = $this->copy();
        $Ml->is_negative = false;
        $QR = new Math_BigInteger();
        $QR->value = array(MATH_BIGINTEGER_MAX10);
        $al = '';
        Sm:
        if (!count($Ml->value)) {
            goto Lo;
        }
        list($Ml, $xj) = $Ml->divide($QR);
        $al = str_pad(isset($xj->value[0]) ? $xj->value[0] : '', MATH_BIGINTEGER_MAX10_LEN, "\x30", STR_PAD_LEFT) . $al;
        goto Sm;
        Lo:
        $al = ltrim($al, "\x30");
        if (!empty($al)) {
            goto vN;
        }
        $al = "\60";
        vN:
        if (!$this->is_negative) {
            goto F4;
        }
        $al = "\x2d" . $al;
        F4:
        return $al;
    }
    function copy()
    {
        $Ml = new Math_BigInteger();
        $Ml->value = $this->value;
        $Ml->is_negative = $this->is_negative;
        $Ml->precision = $this->precision;
        $Ml->bitmask = $this->bitmask;
        return $Ml;
    }
    function __toString()
    {
        return $this->toString();
    }
    function __clone()
    {
        return $this->copy();
    }
    function __sleep()
    {
        $this->hex = $this->toHex(true);
        $ds = array("\150\x65\170");
        if (!($this->precision > 0)) {
            goto gK;
        }
        $ds[] = "\160\x72\x65\143\x69\163\151\x6f\156";
        gK:
        return $ds;
    }
    function __wakeup()
    {
        $Ml = new Math_BigInteger($this->hex, -16);
        $this->value = $Ml->value;
        $this->is_negative = $Ml->is_negative;
        if (!($this->precision > 0)) {
            goto bq;
        }
        $this->setPrecision($this->precision);
        bq:
    }
    function __debugInfo()
    {
        $MU = array();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $hs = "\x67\155\160";
                goto FU;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $hs = "\142\x63\x6d\x61\x74\150";
                goto FU;
            case MATH_BIGINTEGER_MODE_INTERNAL:
                $hs = "\151\156\164\145\162\x6e\x61\x6c";
                $MU[] = PHP_INT_SIZE == 8 ? "\x36\x34\55\x62\151\164" : "\63\x32\x2d\x62\x69\x74";
        }
        l6:
        FU:
        if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_GMP && defined("\115\x41\124\110\x5f\x42\111\x47\111\116\124\x45\107\x45\x52\x5f\x4f\x50\x45\116\x53\x53\114\x5f\105\x4e\x41\102\114\105\x44"))) {
            goto Ht;
        }
        $MU[] = "\x4f\x70\x65\x6e\x53\123\114";
        Ht:
        if (empty($MU)) {
            goto x0;
        }
        $hs .= "\x20\x28" . implode($MU, "\x2c\x20") . "\51";
        x0:
        return array("\166\141\154\x75\x65" => "\x30\170" . $this->toHex(true), "\145\156\x67\x69\x6e\x65" => $hs);
    }
    function add($vN)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_add($this->value, $vN->value);
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml = new Math_BigInteger();
                $Ml->value = bcadd($this->value, $vN->value, 0);
                return $this->_normalize($Ml);
        }
        mu:
        yl:
        $Ml = $this->_add($this->value, $this->is_negative, $vN->value, $vN->is_negative);
        $al = new Math_BigInteger();
        $al->value = $Ml[MATH_BIGINTEGER_VALUE];
        $al->is_negative = $Ml[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($al);
    }
    function _add($CD, $i6, $LU, $SY)
    {
        $N3 = count($CD);
        $KA = count($LU);
        if ($N3 == 0) {
            goto cf;
        }
        if ($KA == 0) {
            goto G1;
        }
        goto Li;
        cf:
        return array(MATH_BIGINTEGER_VALUE => $LU, MATH_BIGINTEGER_SIGN => $SY);
        goto Li;
        G1:
        return array(MATH_BIGINTEGER_VALUE => $CD, MATH_BIGINTEGER_SIGN => $i6);
        Li:
        if (!($i6 != $SY)) {
            goto ye;
        }
        if (!($CD == $LU)) {
            goto DF;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        DF:
        $Ml = $this->_subtract($CD, false, $LU, false);
        $Ml[MATH_BIGINTEGER_SIGN] = $this->_compare($CD, false, $LU, false) > 0 ? $i6 : $SY;
        return $Ml;
        ye:
        if ($N3 < $KA) {
            goto Xv;
        }
        $Rp = $KA;
        $pj = $CD;
        goto eR;
        Xv:
        $Rp = $N3;
        $pj = $LU;
        eR:
        $pj[count($pj)] = 0;
        $x9 = 0;
        $uZ = 0;
        $qP = 1;
        t0:
        if (!($qP < $Rp)) {
            goto AQ;
        }
        $kc = $CD[$qP] * MATH_BIGINTEGER_BASE_FULL + $CD[$uZ] + $LU[$qP] * MATH_BIGINTEGER_BASE_FULL + $LU[$uZ] + $x9;
        $x9 = $kc >= MATH_BIGINTEGER_MAX_DIGIT2;
        $kc = $x9 ? $kc - MATH_BIGINTEGER_MAX_DIGIT2 : $kc;
        $Ml = MATH_BIGINTEGER_BASE === 26 ? intval($kc / 0x4000000) : $kc >> 31;
        $pj[$uZ] = (int) ($kc - MATH_BIGINTEGER_BASE_FULL * $Ml);
        $pj[$qP] = $Ml;
        hX:
        $uZ += 2;
        $qP += 2;
        goto t0;
        AQ:
        if (!($qP == $Rp)) {
            goto Ka;
        }
        $kc = $CD[$uZ] + $LU[$uZ] + $x9;
        $x9 = $kc >= MATH_BIGINTEGER_BASE_FULL;
        $pj[$uZ] = $x9 ? $kc - MATH_BIGINTEGER_BASE_FULL : $kc;
        ++$uZ;
        Ka:
        if (!$x9) {
            goto iI;
        }
        Z5:
        if (!($pj[$uZ] == MATH_BIGINTEGER_MAX_DIGIT)) {
            goto xf;
        }
        $pj[$uZ] = 0;
        Bc:
        ++$uZ;
        goto Z5;
        xf:
        ++$pj[$uZ];
        iI:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($pj), MATH_BIGINTEGER_SIGN => $i6);
    }
    function subtract($vN)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_sub($this->value, $vN->value);
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml = new Math_BigInteger();
                $Ml->value = bcsub($this->value, $vN->value, 0);
                return $this->_normalize($Ml);
        }
        qb:
        V4:
        $Ml = $this->_subtract($this->value, $this->is_negative, $vN->value, $vN->is_negative);
        $al = new Math_BigInteger();
        $al->value = $Ml[MATH_BIGINTEGER_VALUE];
        $al->is_negative = $Ml[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($al);
    }
    function _subtract($CD, $i6, $LU, $SY)
    {
        $N3 = count($CD);
        $KA = count($LU);
        if ($N3 == 0) {
            goto Ky;
        }
        if ($KA == 0) {
            goto ta;
        }
        goto dF;
        Ky:
        return array(MATH_BIGINTEGER_VALUE => $LU, MATH_BIGINTEGER_SIGN => !$SY);
        goto dF;
        ta:
        return array(MATH_BIGINTEGER_VALUE => $CD, MATH_BIGINTEGER_SIGN => $i6);
        dF:
        if (!($i6 != $SY)) {
            goto Jb;
        }
        $Ml = $this->_add($CD, false, $LU, false);
        $Ml[MATH_BIGINTEGER_SIGN] = $i6;
        return $Ml;
        Jb:
        $J_ = $this->_compare($CD, $i6, $LU, $SY);
        if ($J_) {
            goto aE;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        aE:
        if (!(!$i6 && $J_ < 0 || $i6 && $J_ > 0)) {
            goto Kw;
        }
        $Ml = $CD;
        $CD = $LU;
        $LU = $Ml;
        $i6 = !$i6;
        $N3 = count($CD);
        $KA = count($LU);
        Kw:
        $x9 = 0;
        $uZ = 0;
        $qP = 1;
        BA:
        if (!($qP < $KA)) {
            goto RU;
        }
        $kc = $CD[$qP] * MATH_BIGINTEGER_BASE_FULL + $CD[$uZ] - $LU[$qP] * MATH_BIGINTEGER_BASE_FULL - $LU[$uZ] - $x9;
        $x9 = $kc < 0;
        $kc = $x9 ? $kc + MATH_BIGINTEGER_MAX_DIGIT2 : $kc;
        $Ml = MATH_BIGINTEGER_BASE === 26 ? intval($kc / 0x4000000) : $kc >> 31;
        $CD[$uZ] = (int) ($kc - MATH_BIGINTEGER_BASE_FULL * $Ml);
        $CD[$qP] = $Ml;
        Xu:
        $uZ += 2;
        $qP += 2;
        goto BA;
        RU:
        if (!($qP == $KA)) {
            goto pR;
        }
        $kc = $CD[$uZ] - $LU[$uZ] - $x9;
        $x9 = $kc < 0;
        $CD[$uZ] = $x9 ? $kc + MATH_BIGINTEGER_BASE_FULL : $kc;
        ++$uZ;
        pR:
        if (!$x9) {
            goto E5;
        }
        ct:
        if ($CD[$uZ]) {
            goto Ys;
        }
        $CD[$uZ] = MATH_BIGINTEGER_MAX_DIGIT;
        h1:
        ++$uZ;
        goto ct;
        Ys:
        --$CD[$uZ];
        E5:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($CD), MATH_BIGINTEGER_SIGN => $i6);
    }
    function multiply($Rb)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_mul($this->value, $Rb->value);
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml = new Math_BigInteger();
                $Ml->value = bcmul($this->value, $Rb->value, 0);
                return $this->_normalize($Ml);
        }
        DN:
        h2:
        $Ml = $this->_multiply($this->value, $this->is_negative, $Rb->value, $Rb->is_negative);
        $zg = new Math_BigInteger();
        $zg->value = $Ml[MATH_BIGINTEGER_VALUE];
        $zg->is_negative = $Ml[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($zg);
    }
    function _multiply($CD, $i6, $LU, $SY)
    {
        $oc = count($CD);
        $a4 = count($LU);
        if (!(!$oc || !$a4)) {
            goto rH;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        rH:
        return array(MATH_BIGINTEGER_VALUE => min($oc, $a4) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_regularMultiply($CD, $LU)) : $this->_trim($this->_karatsuba($CD, $LU)), MATH_BIGINTEGER_SIGN => $i6 != $SY);
    }
    function _regularMultiply($CD, $LU)
    {
        $oc = count($CD);
        $a4 = count($LU);
        if (!(!$oc || !$a4)) {
            goto RW;
        }
        return array();
        RW:
        if (!($oc < $a4)) {
            goto pD;
        }
        $Ml = $CD;
        $CD = $LU;
        $LU = $Ml;
        $oc = count($CD);
        $a4 = count($LU);
        pD:
        $Wo = $this->_array_repeat(0, $oc + $a4);
        $x9 = 0;
        $qP = 0;
        lF:
        if (!($qP < $oc)) {
            goto I3;
        }
        $Ml = $CD[$qP] * $LU[0] + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $Wo[$qP] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        KW:
        ++$qP;
        goto lF;
        I3:
        $Wo[$qP] = $x9;
        $uZ = 1;
        aN:
        if (!($uZ < $a4)) {
            goto HB;
        }
        $x9 = 0;
        $qP = 0;
        $rY = $uZ;
        C1:
        if (!($qP < $oc)) {
            goto Km;
        }
        $Ml = $Wo[$rY] + $CD[$qP] * $LU[$uZ] + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $Wo[$rY] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        QR:
        ++$qP;
        ++$rY;
        goto C1;
        Km:
        $Wo[$rY] = $x9;
        XS:
        ++$uZ;
        goto aN;
        HB:
        return $Wo;
    }
    function _karatsuba($CD, $LU)
    {
        $cA = min(count($CD) >> 1, count($LU) >> 1);
        if (!($cA < MATH_BIGINTEGER_KARATSUBA_CUTOFF)) {
            goto d3;
        }
        return $this->_regularMultiply($CD, $LU);
        d3:
        $cE = array_slice($CD, $cA);
        $WB = array_slice($CD, 0, $cA);
        $E1 = array_slice($LU, $cA);
        $U_ = array_slice($LU, 0, $cA);
        $qW = $this->_karatsuba($cE, $E1);
        $aM = $this->_karatsuba($WB, $U_);
        $EW = $this->_add($cE, false, $WB, false);
        $Ml = $this->_add($E1, false, $U_, false);
        $EW = $this->_karatsuba($EW[MATH_BIGINTEGER_VALUE], $Ml[MATH_BIGINTEGER_VALUE]);
        $Ml = $this->_add($qW, false, $aM, false);
        $EW = $this->_subtract($EW, false, $Ml[MATH_BIGINTEGER_VALUE], false);
        $qW = array_merge(array_fill(0, 2 * $cA, 0), $qW);
        $EW[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $cA, 0), $EW[MATH_BIGINTEGER_VALUE]);
        $z1 = $this->_add($qW, false, $EW[MATH_BIGINTEGER_VALUE], $EW[MATH_BIGINTEGER_SIGN]);
        $z1 = $this->_add($z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN], $aM, false);
        return $z1[MATH_BIGINTEGER_VALUE];
    }
    function _square($Rb = false)
    {
        return count($Rb) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_baseSquare($Rb)) : $this->_trim($this->_karatsubaSquare($Rb));
    }
    function _baseSquare($pj)
    {
        if (!empty($pj)) {
            goto A8;
        }
        return array();
        A8:
        $xh = $this->_array_repeat(0, 2 * count($pj));
        $uZ = 0;
        $XH = count($pj) - 1;
        lj:
        if (!($uZ <= $XH)) {
            goto ae;
        }
        $mN = $uZ << 1;
        $Ml = $xh[$mN] + $pj[$uZ] * $pj[$uZ];
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $xh[$mN] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        $qP = $uZ + 1;
        $rY = $mN + 1;
        hp:
        if (!($qP <= $XH)) {
            goto bF;
        }
        $Ml = $xh[$rY] + 2 * $pj[$qP] * $pj[$uZ] + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $xh[$rY] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        UW:
        ++$qP;
        ++$rY;
        goto hp;
        bF:
        $xh[$uZ + $XH + 1] = $x9;
        F5:
        ++$uZ;
        goto lj;
        ae:
        return $xh;
    }
    function _karatsubaSquare($pj)
    {
        $cA = count($pj) >> 1;
        if (!($cA < MATH_BIGINTEGER_KARATSUBA_CUTOFF)) {
            goto U4;
        }
        return $this->_baseSquare($pj);
        U4:
        $cE = array_slice($pj, $cA);
        $WB = array_slice($pj, 0, $cA);
        $qW = $this->_karatsubaSquare($cE);
        $aM = $this->_karatsubaSquare($WB);
        $EW = $this->_add($cE, false, $WB, false);
        $EW = $this->_karatsubaSquare($EW[MATH_BIGINTEGER_VALUE]);
        $Ml = $this->_add($qW, false, $aM, false);
        $EW = $this->_subtract($EW, false, $Ml[MATH_BIGINTEGER_VALUE], false);
        $qW = array_merge(array_fill(0, 2 * $cA, 0), $qW);
        $EW[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $cA, 0), $EW[MATH_BIGINTEGER_VALUE]);
        $dq = $this->_add($qW, false, $EW[MATH_BIGINTEGER_VALUE], $EW[MATH_BIGINTEGER_SIGN]);
        $dq = $this->_add($dq[MATH_BIGINTEGER_VALUE], $dq[MATH_BIGINTEGER_SIGN], $aM, false);
        return $dq[MATH_BIGINTEGER_VALUE];
    }
    function divide($vN)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $qK = new Math_BigInteger();
                $OV = new Math_BigInteger();
                list($qK->value, $OV->value) = gmp_div_qr($this->value, $vN->value);
                if (!(gmp_sign($OV->value) < 0)) {
                    goto PO;
                }
                $OV->value = gmp_add($OV->value, gmp_abs($vN->value));
                PO:
                return array($this->_normalize($qK), $this->_normalize($OV));
            case MATH_BIGINTEGER_MODE_BCMATH:
                $qK = new Math_BigInteger();
                $OV = new Math_BigInteger();
                $qK->value = bcdiv($this->value, $vN->value, 0);
                $OV->value = bcmod($this->value, $vN->value);
                if (!($OV->value[0] == "\x2d")) {
                    goto QY;
                }
                $OV->value = bcadd($OV->value, $vN->value[0] == "\x2d" ? substr($vN->value, 1) : $vN->value, 0);
                QY:
                return array($this->_normalize($qK), $this->_normalize($OV));
        }
        wM:
        Br:
        if (!(count($vN->value) == 1)) {
            goto qO;
        }
        list($Cz, $g5) = $this->_divide_digit($this->value, $vN->value[0]);
        $qK = new Math_BigInteger();
        $OV = new Math_BigInteger();
        $qK->value = $Cz;
        $OV->value = array($g5);
        $qK->is_negative = $this->is_negative != $vN->is_negative;
        return array($this->_normalize($qK), $this->_normalize($OV));
        qO:
        static $Zy;
        if (isset($Zy)) {
            goto OT;
        }
        $Zy = new Math_BigInteger();
        OT:
        $Rb = $this->copy();
        $vN = $vN->copy();
        $dl = $Rb->is_negative;
        $KK = $vN->is_negative;
        $Rb->is_negative = $vN->is_negative = false;
        $J_ = $Rb->compare($vN);
        if ($J_) {
            goto ml;
        }
        $Ml = new Math_BigInteger();
        $Ml->value = array(1);
        $Ml->is_negative = $dl != $KK;
        return array($this->_normalize($Ml), $this->_normalize(new Math_BigInteger()));
        ml:
        if (!($J_ < 0)) {
            goto R9;
        }
        if (!$dl) {
            goto Tt;
        }
        $Rb = $vN->subtract($Rb);
        Tt:
        return array($this->_normalize(new Math_BigInteger()), $this->_normalize($Rb));
        R9:
        $Mo = $vN->value[count($vN->value) - 1];
        $tB = 0;
        Ii:
        if ($Mo & MATH_BIGINTEGER_MSB) {
            goto GB;
        }
        $Mo <<= 1;
        mM:
        ++$tB;
        goto Ii;
        GB:
        $Rb->_lshift($tB);
        $vN->_lshift($tB);
        $LU =& $vN->value;
        $NZ = count($Rb->value) - 1;
        $nb = count($vN->value) - 1;
        $qK = new Math_BigInteger();
        $ES =& $qK->value;
        $ES = $this->_array_repeat(0, $NZ - $nb + 1);
        static $Ml, $D8, $ve;
        if (isset($Ml)) {
            goto xn;
        }
        $Ml = new Math_BigInteger();
        $D8 = new Math_BigInteger();
        $ve = new Math_BigInteger();
        xn:
        $up =& $Ml->value;
        $b3 =& $ve->value;
        $up = array_merge($this->_array_repeat(0, $NZ - $nb), $LU);
        ON:
        if (!($Rb->compare($Ml) >= 0)) {
            goto Ra;
        }
        ++$ES[$NZ - $nb];
        $Rb = $Rb->subtract($Ml);
        $NZ = count($Rb->value) - 1;
        goto ON;
        Ra:
        $uZ = $NZ;
        g3:
        if (!($uZ >= $nb + 1)) {
            goto jz;
        }
        $CD =& $Rb->value;
        $ra = array(isset($CD[$uZ]) ? $CD[$uZ] : 0, isset($CD[$uZ - 1]) ? $CD[$uZ - 1] : 0, isset($CD[$uZ - 2]) ? $CD[$uZ - 2] : 0);
        $rK = array($LU[$nb], $nb > 0 ? $LU[$nb - 1] : 0);
        $DL = $uZ - $nb - 1;
        if ($ra[0] == $rK[0]) {
            goto nO;
        }
        $ES[$DL] = $this->_safe_divide($ra[0] * MATH_BIGINTEGER_BASE_FULL + $ra[1], $rK[0]);
        goto iO;
        nO:
        $ES[$DL] = MATH_BIGINTEGER_MAX_DIGIT;
        iO:
        $up = array($rK[1], $rK[0]);
        $D8->value = array($ES[$DL]);
        $D8 = $D8->multiply($Ml);
        $b3 = array($ra[2], $ra[1], $ra[0]);
        K6:
        if (!($D8->compare($ve) > 0)) {
            goto Jf;
        }
        --$ES[$DL];
        $D8->value = array($ES[$DL]);
        $D8 = $D8->multiply($Ml);
        goto K6;
        Jf:
        $Zs = $this->_array_repeat(0, $DL);
        $up = array($ES[$DL]);
        $Ml = $Ml->multiply($vN);
        $up =& $Ml->value;
        $up = array_merge($Zs, $up);
        $Rb = $Rb->subtract($Ml);
        if (!($Rb->compare($Zy) < 0)) {
            goto aK;
        }
        $up = array_merge($Zs, $LU);
        $Rb = $Rb->add($Ml);
        --$ES[$DL];
        aK:
        $NZ = count($CD) - 1;
        mZ:
        --$uZ;
        goto g3;
        jz:
        $Rb->_rshift($tB);
        $qK->is_negative = $dl != $KK;
        if (!$dl) {
            goto hj;
        }
        $vN->_rshift($tB);
        $Rb = $vN->subtract($Rb);
        hj:
        return array($this->_normalize($qK), $this->_normalize($Rb));
    }
    function _divide_digit($bG, $QR)
    {
        $x9 = 0;
        $al = array();
        $uZ = count($bG) - 1;
        oD:
        if (!($uZ >= 0)) {
            goto Sz;
        }
        $Ml = MATH_BIGINTEGER_BASE_FULL * $x9 + $bG[$uZ];
        $al[$uZ] = $this->_safe_divide($Ml, $QR);
        $x9 = (int) ($Ml - $QR * $al[$uZ]);
        WO:
        --$uZ;
        goto oD;
        Sz:
        return array($al, $x9);
    }
    function modPow($fW, $xJ)
    {
        $xJ = $this->bitmask !== false && $this->bitmask->compare($xJ) < 0 ? $this->bitmask : $xJ->abs();
        if (!($fW->compare(new Math_BigInteger()) < 0)) {
            goto My;
        }
        $fW = $fW->abs();
        $Ml = $this->modInverse($xJ);
        if (!($Ml === false)) {
            goto Tw;
        }
        return false;
        Tw:
        return $this->_normalize($Ml->modPow($fW, $xJ));
        My:
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP)) {
            goto V1;
        }
        $Ml = new Math_BigInteger();
        $Ml->value = gmp_powm($this->value, $fW->value, $xJ->value);
        return $this->_normalize($Ml);
        V1:
        if (!($this->compare(new Math_BigInteger()) < 0 || $this->compare($xJ) > 0)) {
            goto FJ;
        }
        list(, $Ml) = $this->divide($xJ);
        return $Ml->modPow($fW, $xJ);
        FJ:
        if (!defined("\x4d\101\x54\x48\x5f\102\x49\x47\x49\x4e\x54\105\x47\x45\122\137\x4f\x50\105\x4e\123\x53\114\137\x45\x4e\101\102\x4c\105\104")) {
            goto yi;
        }
        $OP = array("\155\x6f\144\165\x6c\x75\163" => $xJ->toBytes(true), "\160\x75\x62\x6c\151\143\x45\170\x70\x6f\156\x65\156\x74" => $fW->toBytes(true));
        $OP = array("\x6d\157\x64\165\154\165\163" => pack("\103\141\52\x61\x2a", 2, $this->_encodeASN1Length(strlen($OP["\155\x6f\144\x75\x6c\165\x73"])), $OP["\155\157\x64\x75\x6c\165\163"]), "\x70\165\x62\x6c\x69\143\105\x78\x70\157\x6e\145\156\x74" => pack("\x43\141\x2a\x61\x2a", 2, $this->_encodeASN1Length(strlen($OP["\160\165\142\154\151\143\x45\170\x70\157\x6e\145\156\164"])), $OP["\160\x75\142\x6c\151\143\105\x78\160\157\x6e\x65\x6e\x74"]));
        $qx = pack("\103\141\52\141\x2a\141\x2a", 48, $this->_encodeASN1Length(strlen($OP["\x6d\157\144\165\154\165\163"]) + strlen($OP["\x70\165\x62\154\151\143\105\x78\x70\x6f\156\x65\x6e\x74"])), $OP["\155\157\144\x75\x6c\165\x73"], $OP["\x70\x75\x62\x6c\x69\143\x45\x78\160\157\x6e\x65\x6e\164"]);
        $k7 = pack("\110\52", "\x33\x30\x30\144\x30\x36\60\x39\62\x61\x38\x36\x34\70\70\66\146\x37\x30\144\x30\61\60\x31\60\x31\60\x35\x30\x30");
        $qx = chr(0) . $qx;
        $qx = chr(3) . $this->_encodeASN1Length(strlen($qx)) . $qx;
        $KH = pack("\x43\x61\x2a\x61\x2a", 48, $this->_encodeASN1Length(strlen($k7 . $qx)), $k7 . $qx);
        $qx = "\55\55\55\x2d\x2d\x42\x45\107\111\x4e\x20\x50\125\x42\114\x49\x43\x20\x4b\x45\x59\x2d\55\x2d\x2d\x2d\xd\xa" . chunk_split(base64_encode($KH)) . "\55\x2d\55\x2d\55\x45\116\104\40\120\x55\102\x4c\111\x43\x20\x4b\105\x59\x2d\55\55\55\55";
        $Ys = str_pad($this->toBytes(), strlen($xJ->toBytes(true)) - 1, "\x0", STR_PAD_LEFT);
        if (!openssl_public_encrypt($Ys, $al, $qx, OPENSSL_NO_PADDING)) {
            goto Ua;
        }
        return new Math_BigInteger($al, 256);
        Ua:
        yi:
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH)) {
            goto rC;
        }
        $Ml = new Math_BigInteger();
        $Ml->value = bcpowmod($this->value, $fW->value, $xJ->value, 0);
        return $this->_normalize($Ml);
        rC:
        if (!empty($fW->value)) {
            goto cy;
        }
        $Ml = new Math_BigInteger();
        $Ml->value = array(1);
        return $this->_normalize($Ml);
        cy:
        if (!($fW->value == array(1))) {
            goto KV;
        }
        list(, $Ml) = $this->divide($xJ);
        return $this->_normalize($Ml);
        KV:
        if (!($fW->value == array(2))) {
            goto dA;
        }
        $Ml = new Math_BigInteger();
        $Ml->value = $this->_square($this->value);
        list(, $Ml) = $Ml->divide($xJ);
        return $this->_normalize($Ml);
        dA:
        return $this->_normalize($this->_slidingWindow($fW, $xJ, MATH_BIGINTEGER_BARRETT));
        if (!($xJ->value[0] & 1)) {
            goto Mm;
        }
        return $this->_normalize($this->_slidingWindow($fW, $xJ, MATH_BIGINTEGER_MONTGOMERY));
        Mm:
        $uZ = 0;
        jB:
        if (!($uZ < count($xJ->value))) {
            goto Be;
        }
        if (!$xJ->value[$uZ]) {
            goto Ut;
        }
        $Ml = decbin($xJ->value[$uZ]);
        $qP = strlen($Ml) - strrpos($Ml, "\61") - 1;
        $qP += 26 * $uZ;
        goto Be;
        Ut:
        G4:
        ++$uZ;
        goto jB;
        Be:
        $Av = $xJ->copy();
        $Av->_rshift($qP);
        $Bi = new Math_BigInteger();
        $Bi->value = array(1);
        $Bi->_lshift($qP);
        $mt = $Av->value != array(1) ? $this->_slidingWindow($fW, $Av, MATH_BIGINTEGER_MONTGOMERY) : new Math_BigInteger();
        $b6 = $this->_slidingWindow($fW, $Bi, MATH_BIGINTEGER_POWEROF2);
        $E1 = $Bi->modInverse($Av);
        $dk = $Av->modInverse($Bi);
        $al = $mt->multiply($Bi);
        $al = $al->multiply($E1);
        $Ml = $b6->multiply($Av);
        $Ml = $Ml->multiply($dk);
        $al = $al->add($Ml);
        list(, $al) = $al->divide($xJ);
        return $this->_normalize($al);
    }
    function powMod($fW, $xJ)
    {
        return $this->modPow($fW, $xJ);
    }
    function _slidingWindow($fW, $xJ, $qp)
    {
        static $Hk = array(7, 25, 81, 241, 673, 1793);
        $hl = $fW->value;
        $Ip = count($hl) - 1;
        $kp = decbin($hl[$Ip]);
        $uZ = $Ip - 1;
        mc:
        if (!($uZ >= 0)) {
            goto li;
        }
        $kp .= str_pad(decbin($hl[$uZ]), MATH_BIGINTEGER_BASE, "\60", STR_PAD_LEFT);
        bI:
        --$uZ;
        goto mc;
        li:
        $Ip = strlen($kp);
        $uZ = 0;
        $ed = 1;
        NF:
        if (!($uZ < count($Hk) && $Ip > $Hk[$uZ])) {
            goto Q7;
        }
        lQ:
        ++$ed;
        ++$uZ;
        goto NF;
        Q7:
        $ZX = $xJ->value;
        $LC = array();
        $LC[1] = $this->_prepareReduce($this->value, $ZX, $qp);
        $LC[2] = $this->_squareReduce($LC[1], $ZX, $qp);
        $Ml = 1 << $ed - 1;
        $uZ = 1;
        fU:
        if (!($uZ < $Ml)) {
            goto s3;
        }
        $mN = $uZ << 1;
        $LC[$mN + 1] = $this->_multiplyReduce($LC[$mN - 1], $LC[2], $ZX, $qp);
        Rx:
        ++$uZ;
        goto fU;
        s3:
        $al = array(1);
        $al = $this->_prepareReduce($al, $ZX, $qp);
        $uZ = 0;
        QW:
        if (!($uZ < $Ip)) {
            goto S6;
        }
        if (!$kp[$uZ]) {
            goto h0;
        }
        $qP = $ed - 1;
        Wh:
        if (!($qP > 0)) {
            goto Ze;
        }
        if (empty($kp[$uZ + $qP])) {
            goto js;
        }
        goto Ze;
        js:
        vr:
        --$qP;
        goto Wh;
        Ze:
        $rY = 0;
        l3:
        if (!($rY <= $qP)) {
            goto NR;
        }
        $al = $this->_squareReduce($al, $ZX, $qp);
        g4:
        ++$rY;
        goto l3;
        NR:
        $al = $this->_multiplyReduce($al, $LC[bindec(substr($kp, $uZ, $qP + 1))], $ZX, $qp);
        $uZ += $qP + 1;
        goto De;
        h0:
        $al = $this->_squareReduce($al, $ZX, $qp);
        ++$uZ;
        De:
        XK:
        goto QW;
        S6:
        $Ml = new Math_BigInteger();
        $Ml->value = $this->_reduce($al, $ZX, $qp);
        return $Ml;
    }
    function _reduce($Rb, $xJ, $qp)
    {
        switch ($qp) {
            case MATH_BIGINTEGER_MONTGOMERY:
                return $this->_montgomery($Rb, $xJ);
            case MATH_BIGINTEGER_BARRETT:
                return $this->_barrett($Rb, $xJ);
            case MATH_BIGINTEGER_POWEROF2:
                $D8 = new Math_BigInteger();
                $D8->value = $Rb;
                $ve = new Math_BigInteger();
                $ve->value = $xJ;
                return $Rb->_mod2($xJ);
            case MATH_BIGINTEGER_CLASSIC:
                $D8 = new Math_BigInteger();
                $D8->value = $Rb;
                $ve = new Math_BigInteger();
                $ve->value = $xJ;
                list(, $Ml) = $D8->divide($ve);
                return $Ml->value;
            case MATH_BIGINTEGER_NONE:
                return $Rb;
            default:
        }
        ba:
        f1:
    }
    function _prepareReduce($Rb, $xJ, $qp)
    {
        if (!($qp == MATH_BIGINTEGER_MONTGOMERY)) {
            goto aa;
        }
        return $this->_prepMontgomery($Rb, $xJ);
        aa:
        return $this->_reduce($Rb, $xJ, $qp);
    }
    function _multiplyReduce($Rb, $vN, $xJ, $qp)
    {
        if (!($qp == MATH_BIGINTEGER_MONTGOMERY)) {
            goto cO;
        }
        return $this->_montgomeryMultiply($Rb, $vN, $xJ);
        cO:
        $Ml = $this->_multiply($Rb, false, $vN, false);
        return $this->_reduce($Ml[MATH_BIGINTEGER_VALUE], $xJ, $qp);
    }
    function _squareReduce($Rb, $xJ, $qp)
    {
        if (!($qp == MATH_BIGINTEGER_MONTGOMERY)) {
            goto x3;
        }
        return $this->_montgomeryMultiply($Rb, $Rb, $xJ);
        x3:
        return $this->_reduce($this->_square($Rb), $xJ, $qp);
    }
    function _mod2($xJ)
    {
        $Ml = new Math_BigInteger();
        $Ml->value = array(1);
        return $this->bitwise_and($xJ->subtract($Ml));
    }
    function _barrett($xJ, $cA)
    {
        static $Hb = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        $jR = count($cA);
        if (!(count($xJ) > 2 * $jR)) {
            goto I1;
        }
        $D8 = new Math_BigInteger();
        $ve = new Math_BigInteger();
        $D8->value = $xJ;
        $ve->value = $cA;
        list(, $Ml) = $D8->divide($ve);
        return $Ml->value;
        I1:
        if (!($jR < 5)) {
            goto CJ;
        }
        return $this->_regularBarrett($xJ, $cA);
        CJ:
        if (($O8 = array_search($cA, $Hb[MATH_BIGINTEGER_VARIABLE])) === false) {
            goto U7;
        }
        extract($Hb[MATH_BIGINTEGER_DATA][$O8]);
        goto t7;
        U7:
        $O8 = count($Hb[MATH_BIGINTEGER_VARIABLE]);
        $Hb[MATH_BIGINTEGER_VARIABLE][] = $cA;
        $D8 = new Math_BigInteger();
        $tF =& $D8->value;
        $tF = $this->_array_repeat(0, $jR + ($jR >> 1));
        $tF[] = 1;
        $ve = new Math_BigInteger();
        $ve->value = $cA;
        list($Sh, $Wy) = $D8->divide($ve);
        $Sh = $Sh->value;
        $Wy = $Wy->value;
        $Hb[MATH_BIGINTEGER_DATA][] = array("\165" => $Sh, "\x6d\61" => $Wy);
        t7:
        $WF = $jR + ($jR >> 1);
        $ka = array_slice($xJ, 0, $WF);
        $hb = array_slice($xJ, $WF);
        $ka = $this->_trim($ka);
        $Ml = $this->_multiply($hb, false, $Wy, false);
        $xJ = $this->_add($ka, false, $Ml[MATH_BIGINTEGER_VALUE], false);
        if (!($jR & 1)) {
            goto Bv;
        }
        return $this->_regularBarrett($xJ[MATH_BIGINTEGER_VALUE], $cA);
        Bv:
        $Ml = array_slice($xJ[MATH_BIGINTEGER_VALUE], $jR - 1);
        $Ml = $this->_multiply($Ml, false, $Sh, false);
        $Ml = array_slice($Ml[MATH_BIGINTEGER_VALUE], ($jR >> 1) + 1);
        $Ml = $this->_multiply($Ml, false, $cA, false);
        $al = $this->_subtract($xJ[MATH_BIGINTEGER_VALUE], false, $Ml[MATH_BIGINTEGER_VALUE], false);
        Nl:
        if (!($this->_compare($al[MATH_BIGINTEGER_VALUE], $al[MATH_BIGINTEGER_SIGN], $cA, false) >= 0)) {
            goto Di;
        }
        $al = $this->_subtract($al[MATH_BIGINTEGER_VALUE], $al[MATH_BIGINTEGER_SIGN], $cA, false);
        goto Nl;
        Di:
        return $al[MATH_BIGINTEGER_VALUE];
    }
    function _regularBarrett($Rb, $xJ)
    {
        static $Hb = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        $qd = count($xJ);
        if (!(count($Rb) > 2 * $qd)) {
            goto Eh;
        }
        $D8 = new Math_BigInteger();
        $ve = new Math_BigInteger();
        $D8->value = $Rb;
        $ve->value = $xJ;
        list(, $Ml) = $D8->divide($ve);
        return $Ml->value;
        Eh:
        if (!(($O8 = array_search($xJ, $Hb[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto UG;
        }
        $O8 = count($Hb[MATH_BIGINTEGER_VARIABLE]);
        $Hb[MATH_BIGINTEGER_VARIABLE][] = $xJ;
        $D8 = new Math_BigInteger();
        $tF =& $D8->value;
        $tF = $this->_array_repeat(0, 2 * $qd);
        $tF[] = 1;
        $ve = new Math_BigInteger();
        $ve->value = $xJ;
        list($Ml, ) = $D8->divide($ve);
        $Hb[MATH_BIGINTEGER_DATA][] = $Ml->value;
        UG:
        $Ml = array_slice($Rb, $qd - 1);
        $Ml = $this->_multiply($Ml, false, $Hb[MATH_BIGINTEGER_DATA][$O8], false);
        $Ml = array_slice($Ml[MATH_BIGINTEGER_VALUE], $qd + 1);
        $al = array_slice($Rb, 0, $qd + 1);
        $Ml = $this->_multiplyLower($Ml, false, $xJ, false, $qd + 1);
        if (!($this->_compare($al, false, $Ml[MATH_BIGINTEGER_VALUE], $Ml[MATH_BIGINTEGER_SIGN]) < 0)) {
            goto LT;
        }
        $XK = $this->_array_repeat(0, $qd + 1);
        $XK[count($XK)] = 1;
        $al = $this->_add($al, false, $XK, false);
        $al = $al[MATH_BIGINTEGER_VALUE];
        LT:
        $al = $this->_subtract($al, false, $Ml[MATH_BIGINTEGER_VALUE], $Ml[MATH_BIGINTEGER_SIGN]);
        x9:
        if (!($this->_compare($al[MATH_BIGINTEGER_VALUE], $al[MATH_BIGINTEGER_SIGN], $xJ, false) > 0)) {
            goto We;
        }
        $al = $this->_subtract($al[MATH_BIGINTEGER_VALUE], $al[MATH_BIGINTEGER_SIGN], $xJ, false);
        goto x9;
        We:
        return $al[MATH_BIGINTEGER_VALUE];
    }
    function _multiplyLower($CD, $i6, $LU, $SY, $G8)
    {
        $oc = count($CD);
        $a4 = count($LU);
        if (!(!$oc || !$a4)) {
            goto Ap;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        Ap:
        if (!($oc < $a4)) {
            goto en;
        }
        $Ml = $CD;
        $CD = $LU;
        $LU = $Ml;
        $oc = count($CD);
        $a4 = count($LU);
        en:
        $Wo = $this->_array_repeat(0, $oc + $a4);
        $x9 = 0;
        $qP = 0;
        EE:
        if (!($qP < $oc)) {
            goto vR;
        }
        $Ml = $CD[$qP] * $LU[0] + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $Wo[$qP] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        PS:
        ++$qP;
        goto EE;
        vR:
        if (!($qP < $G8)) {
            goto vf;
        }
        $Wo[$qP] = $x9;
        vf:
        $uZ = 1;
        l9:
        if (!($uZ < $a4)) {
            goto sT;
        }
        $x9 = 0;
        $qP = 0;
        $rY = $uZ;
        eS:
        if (!($qP < $oc && $rY < $G8)) {
            goto wa;
        }
        $Ml = $Wo[$rY] + $CD[$qP] * $LU[$uZ] + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $Wo[$rY] = (int) ($Ml - MATH_BIGINTEGER_BASE_FULL * $x9);
        tD:
        ++$qP;
        ++$rY;
        goto eS;
        wa:
        if (!($rY < $G8)) {
            goto jM;
        }
        $Wo[$rY] = $x9;
        jM:
        du:
        ++$uZ;
        goto l9;
        sT:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($Wo), MATH_BIGINTEGER_SIGN => $i6 != $SY);
    }
    function _montgomery($Rb, $xJ)
    {
        static $Hb = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        if (!(($O8 = array_search($xJ, $Hb[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto qR;
        }
        $O8 = count($Hb[MATH_BIGINTEGER_VARIABLE]);
        $Hb[MATH_BIGINTEGER_VARIABLE][] = $Rb;
        $Hb[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($xJ);
        qR:
        $rY = count($xJ);
        $al = array(MATH_BIGINTEGER_VALUE => $Rb);
        $uZ = 0;
        vF:
        if (!($uZ < $rY)) {
            goto FW;
        }
        $Ml = $al[MATH_BIGINTEGER_VALUE][$uZ] * $Hb[MATH_BIGINTEGER_DATA][$O8];
        $Ml = $Ml - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31);
        $Ml = $this->_regularMultiply(array($Ml), $xJ);
        $Ml = array_merge($this->_array_repeat(0, $uZ), $Ml);
        $al = $this->_add($al[MATH_BIGINTEGER_VALUE], false, $Ml, false);
        GA:
        ++$uZ;
        goto vF;
        FW:
        $al[MATH_BIGINTEGER_VALUE] = array_slice($al[MATH_BIGINTEGER_VALUE], $rY);
        if (!($this->_compare($al, false, $xJ, false) >= 0)) {
            goto xe;
        }
        $al = $this->_subtract($al[MATH_BIGINTEGER_VALUE], false, $xJ, false);
        xe:
        return $al[MATH_BIGINTEGER_VALUE];
    }
    function _montgomeryMultiply($Rb, $vN, $cA)
    {
        $Ml = $this->_multiply($Rb, false, $vN, false);
        return $this->_montgomery($Ml[MATH_BIGINTEGER_VALUE], $cA);
        static $Hb = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        if (!(($O8 = array_search($cA, $Hb[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto Nr;
        }
        $O8 = count($Hb[MATH_BIGINTEGER_VARIABLE]);
        $Hb[MATH_BIGINTEGER_VARIABLE][] = $cA;
        $Hb[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($cA);
        Nr:
        $xJ = max(count($Rb), count($vN), count($cA));
        $Rb = array_pad($Rb, $xJ, 0);
        $vN = array_pad($vN, $xJ, 0);
        $cA = array_pad($cA, $xJ, 0);
        $OZ = array(MATH_BIGINTEGER_VALUE => $this->_array_repeat(0, $xJ + 1));
        $uZ = 0;
        r6:
        if (!($uZ < $xJ)) {
            goto hx;
        }
        $Ml = $OZ[MATH_BIGINTEGER_VALUE][0] + $Rb[$uZ] * $vN[0];
        $Ml = $Ml - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31);
        $Ml = $Ml * $Hb[MATH_BIGINTEGER_DATA][$O8];
        $Ml = $Ml - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31);
        $Ml = $this->_add($this->_regularMultiply(array($Rb[$uZ]), $vN), false, $this->_regularMultiply(array($Ml), $cA), false);
        $OZ = $this->_add($OZ[MATH_BIGINTEGER_VALUE], false, $Ml[MATH_BIGINTEGER_VALUE], false);
        $OZ[MATH_BIGINTEGER_VALUE] = array_slice($OZ[MATH_BIGINTEGER_VALUE], 1);
        q3:
        ++$uZ;
        goto r6;
        hx:
        if (!($this->_compare($OZ[MATH_BIGINTEGER_VALUE], false, $cA, false) >= 0)) {
            goto ul;
        }
        $OZ = $this->_subtract($OZ[MATH_BIGINTEGER_VALUE], false, $cA, false);
        ul:
        return $OZ[MATH_BIGINTEGER_VALUE];
    }
    function _prepMontgomery($Rb, $xJ)
    {
        $D8 = new Math_BigInteger();
        $D8->value = array_merge($this->_array_repeat(0, count($xJ)), $Rb);
        $ve = new Math_BigInteger();
        $ve->value = $xJ;
        list(, $Ml) = $D8->divide($ve);
        return $Ml->value;
    }
    function _modInverse67108864($Rb)
    {
        $Rb = -$Rb[0];
        $al = $Rb & 0x3;
        $al = $al * (2 - $Rb * $al) & 0xf;
        $al = $al * (2 - ($Rb & 0xff) * $al) & 0xff;
        $al = $al * (2 - ($Rb & 0xffff) * $al & 0xffff) & 0xffff;
        $al = fmod($al * (2 - fmod($Rb * $al, MATH_BIGINTEGER_BASE_FULL)), MATH_BIGINTEGER_BASE_FULL);
        return $al & MATH_BIGINTEGER_MAX_DIGIT;
    }
    function modInverse($xJ)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_invert($this->value, $xJ->value);
                return $Ml->value === false ? false : $this->_normalize($Ml);
        }
        oe:
        hZ:
        static $Zy, $is;
        if (isset($Zy)) {
            goto V6;
        }
        $Zy = new Math_BigInteger();
        $is = new Math_BigInteger(1);
        V6:
        $xJ = $xJ->abs();
        if (!($this->compare($Zy) < 0)) {
            goto eU;
        }
        $Ml = $this->abs();
        $Ml = $Ml->modInverse($xJ);
        return $this->_normalize($xJ->subtract($Ml));
        eU:
        extract($this->extendedGCD($xJ));
        if ($ya->equals($is)) {
            goto jk;
        }
        return false;
        jk:
        $Rb = $Rb->compare($Zy) < 0 ? $Rb->add($xJ) : $Rb;
        return $this->compare($Zy) < 0 ? $this->_normalize($xJ->subtract($Rb)) : $this->_normalize($Rb);
    }
    function extendedGCD($xJ)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                extract(gmp_gcdext($this->value, $xJ->value));
                return array("\x67\143\144" => $this->_normalize(new Math_BigInteger($FZ)), "\170" => $this->_normalize(new Math_BigInteger($rM)), "\171" => $this->_normalize(new Math_BigInteger($I0)));
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Sh = $this->value;
                $sM = $xJ->value;
                $OZ = "\61";
                $Je = "\60";
                $GB = "\x30";
                $pi = "\x31";
                S_:
                if (!(bccomp($sM, "\x30", 0) != 0)) {
                    goto NM;
                }
                $Cz = bcdiv($Sh, $sM, 0);
                $Ml = $Sh;
                $Sh = $sM;
                $sM = bcsub($Ml, bcmul($sM, $Cz, 0), 0);
                $Ml = $OZ;
                $OZ = $GB;
                $GB = bcsub($Ml, bcmul($OZ, $Cz, 0), 0);
                $Ml = $Je;
                $Je = $pi;
                $pi = bcsub($Ml, bcmul($Je, $Cz, 0), 0);
                goto S_;
                NM:
                return array("\147\x63\x64" => $this->_normalize(new Math_BigInteger($Sh)), "\x78" => $this->_normalize(new Math_BigInteger($OZ)), "\171" => $this->_normalize(new Math_BigInteger($Je)));
        }
        A6:
        Rw:
        $vN = $xJ->copy();
        $Rb = $this->copy();
        $FZ = new Math_BigInteger();
        $FZ->value = array(1);
        by:
        if ($Rb->value[0] & 1 || $vN->value[0] & 1) {
            goto Pb;
        }
        $Rb->_rshift(1);
        $vN->_rshift(1);
        $FZ->_lshift(1);
        goto by;
        Pb:
        $Sh = $Rb->copy();
        $sM = $vN->copy();
        $OZ = new Math_BigInteger();
        $Je = new Math_BigInteger();
        $GB = new Math_BigInteger();
        $pi = new Math_BigInteger();
        $OZ->value = $pi->value = $FZ->value = array(1);
        $Je->value = $GB->value = array();
        bA:
        if (empty($Sh->value)) {
            goto Oi;
        }
        Ji:
        if ($Sh->value[0] & 1) {
            goto cs;
        }
        $Sh->_rshift(1);
        if (!(!empty($OZ->value) && $OZ->value[0] & 1 || !empty($Je->value) && $Je->value[0] & 1)) {
            goto hK;
        }
        $OZ = $OZ->add($vN);
        $Je = $Je->subtract($Rb);
        hK:
        $OZ->_rshift(1);
        $Je->_rshift(1);
        goto Ji;
        cs:
        nC:
        if ($sM->value[0] & 1) {
            goto p3;
        }
        $sM->_rshift(1);
        if (!(!empty($pi->value) && $pi->value[0] & 1 || !empty($GB->value) && $GB->value[0] & 1)) {
            goto LP;
        }
        $GB = $GB->add($vN);
        $pi = $pi->subtract($Rb);
        LP:
        $GB->_rshift(1);
        $pi->_rshift(1);
        goto nC;
        p3:
        if ($Sh->compare($sM) >= 0) {
            goto Uh;
        }
        $sM = $sM->subtract($Sh);
        $GB = $GB->subtract($OZ);
        $pi = $pi->subtract($Je);
        goto H4;
        Uh:
        $Sh = $Sh->subtract($sM);
        $OZ = $OZ->subtract($GB);
        $Je = $Je->subtract($pi);
        H4:
        goto bA;
        Oi:
        return array("\147\x63\144" => $this->_normalize($FZ->multiply($sM)), "\170" => $this->_normalize($GB), "\x79" => $this->_normalize($pi));
    }
    function gcd($xJ)
    {
        extract($this->extendedGCD($xJ));
        return $ya;
    }
    function abs()
    {
        $Ml = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml->value = gmp_abs($this->value);
                goto C6;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml->value = bccomp($this->value, "\60", 0) < 0 ? substr($this->value, 1) : $this->value;
                goto C6;
            default:
                $Ml->value = $this->value;
        }
        ts:
        C6:
        return $Ml;
    }
    function compare($vN)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $vN->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                return bccomp($this->value, $vN->value, 0);
        }
        io:
        I5:
        return $this->_compare($this->value, $this->is_negative, $vN->value, $vN->is_negative);
    }
    function _compare($CD, $i6, $LU, $SY)
    {
        if (!($i6 != $SY)) {
            goto Oe;
        }
        return !$i6 && $SY ? 1 : -1;
        Oe:
        $al = $i6 ? -1 : 1;
        if (!(count($CD) != count($LU))) {
            goto Fo;
        }
        return count($CD) > count($LU) ? $al : -$al;
        Fo:
        $Rp = max(count($CD), count($LU));
        $CD = array_pad($CD, $Rp, 0);
        $LU = array_pad($LU, $Rp, 0);
        $uZ = count($CD) - 1;
        W9:
        if (!($uZ >= 0)) {
            goto u1;
        }
        if (!($CD[$uZ] != $LU[$uZ])) {
            goto jw;
        }
        return $CD[$uZ] > $LU[$uZ] ? $al : -$al;
        jw:
        Pi:
        --$uZ;
        goto W9;
        u1:
        return 0;
    }
    function equals($Rb)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $Rb->value) == 0;
            default:
                return $this->value === $Rb->value && $this->is_negative == $Rb->is_negative;
        }
        G_:
        bJ:
    }
    function setPrecision($YP)
    {
        $this->precision = $YP;
        if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH) {
            goto n6;
        }
        $this->bitmask = new Math_BigInteger(bcpow("\x32", $YP, 0));
        goto j6;
        n6:
        $this->bitmask = new Math_BigInteger(chr((1 << ($YP & 0x7)) - 1) . str_repeat(chr(0xff), $YP >> 3), 256);
        j6:
        $Ml = $this->_normalize($this);
        $this->value = $Ml->value;
    }
    function bitwise_and($Rb)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_and($this->value, $Rb->value);
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $v1 = $this->toBytes();
                $rm = $Rb->toBytes();
                $iI = max(strlen($v1), strlen($rm));
                $v1 = str_pad($v1, $iI, chr(0), STR_PAD_LEFT);
                $rm = str_pad($rm, $iI, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($v1 & $rm, 256));
        }
        PG:
        xw:
        $al = $this->copy();
        $iI = min(count($Rb->value), count($this->value));
        $al->value = array_slice($al->value, 0, $iI);
        $uZ = 0;
        Vf:
        if (!($uZ < $iI)) {
            goto VQ;
        }
        $al->value[$uZ] &= $Rb->value[$uZ];
        VR:
        ++$uZ;
        goto Vf;
        VQ:
        return $this->_normalize($al);
    }
    function bitwise_or($Rb)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_or($this->value, $Rb->value);
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $v1 = $this->toBytes();
                $rm = $Rb->toBytes();
                $iI = max(strlen($v1), strlen($rm));
                $v1 = str_pad($v1, $iI, chr(0), STR_PAD_LEFT);
                $rm = str_pad($rm, $iI, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($v1 | $rm, 256));
        }
        mv:
        AL:
        $iI = max(count($this->value), count($Rb->value));
        $al = $this->copy();
        $al->value = array_pad($al->value, $iI, 0);
        $Rb->value = array_pad($Rb->value, $iI, 0);
        $uZ = 0;
        RX:
        if (!($uZ < $iI)) {
            goto q5;
        }
        $al->value[$uZ] |= $Rb->value[$uZ];
        Gv:
        ++$uZ;
        goto RX;
        q5:
        return $this->_normalize($al);
    }
    function bitwise_xor($Rb)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $Ml = new Math_BigInteger();
                $Ml->value = gmp_xor(gmp_abs($this->value), gmp_abs($Rb->value));
                return $this->_normalize($Ml);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $v1 = $this->toBytes();
                $rm = $Rb->toBytes();
                $iI = max(strlen($v1), strlen($rm));
                $v1 = str_pad($v1, $iI, chr(0), STR_PAD_LEFT);
                $rm = str_pad($rm, $iI, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($v1 ^ $rm, 256));
        }
        p1:
        qN:
        $iI = max(count($this->value), count($Rb->value));
        $al = $this->copy();
        $al->is_negative = false;
        $al->value = array_pad($al->value, $iI, 0);
        $Rb->value = array_pad($Rb->value, $iI, 0);
        $uZ = 0;
        mA:
        if (!($uZ < $iI)) {
            goto Zq;
        }
        $al->value[$uZ] ^= $Rb->value[$uZ];
        Ug:
        ++$uZ;
        goto mA;
        Zq:
        return $this->_normalize($al);
    }
    function bitwise_not()
    {
        $Ml = $this->toBytes();
        if (!($Ml == '')) {
            goto bK;
        }
        return $this->_normalize(new Math_BigInteger());
        bK:
        $gx = decbin(ord($Ml[0]));
        $Ml = ~$Ml;
        $Mo = decbin(ord($Ml[0]));
        if (!(strlen($Mo) == 8)) {
            goto mb;
        }
        $Mo = substr($Mo, strpos($Mo, "\x30"));
        mb:
        $Ml[0] = chr(bindec($Mo));
        $sw = strlen($gx) + 8 * strlen($Ml) - 8;
        $yq = $this->precision - $sw;
        if (!($yq <= 0)) {
            goto O6;
        }
        return $this->_normalize(new Math_BigInteger($Ml, 256));
        O6:
        $C2 = chr((1 << ($yq & 0x7)) - 1) . str_repeat(chr(0xff), $yq >> 3);
        $this->_base256_lshift($C2, $sw);
        $Ml = str_pad($Ml, strlen($C2), chr(0), STR_PAD_LEFT);
        return $this->_normalize(new Math_BigInteger($C2 | $Ml, 256));
    }
    function bitwise_rightShift($tB)
    {
        $Ml = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $m2;
                if (isset($m2)) {
                    goto Kq;
                }
                $m2 = gmp_init("\62");
                Kq:
                $Ml->value = gmp_div_q($this->value, gmp_pow($m2, $tB));
                goto dX;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml->value = bcdiv($this->value, bcpow("\x32", $tB, 0), 0);
                goto dX;
            default:
                $Ml->value = $this->value;
                $Ml->_rshift($tB);
        }
        Tv:
        dX:
        return $this->_normalize($Ml);
    }
    function bitwise_leftShift($tB)
    {
        $Ml = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $m2;
                if (isset($m2)) {
                    goto kL;
                }
                $m2 = gmp_init("\62");
                kL:
                $Ml->value = gmp_mul($this->value, gmp_pow($m2, $tB));
                goto GR;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $Ml->value = bcmul($this->value, bcpow("\62", $tB, 0), 0);
                goto GR;
            default:
                $Ml->value = $this->value;
                $Ml->_lshift($tB);
        }
        xb:
        GR:
        return $this->_normalize($Ml);
    }
    function bitwise_leftRotate($tB)
    {
        $YP = $this->toBytes();
        if ($this->precision > 0) {
            goto P7;
        }
        $Ml = ord($YP[0]);
        $uZ = 0;
        Ds:
        if (!($Ml >> $uZ)) {
            goto Yq;
        }
        bS:
        ++$uZ;
        goto Ds;
        Yq:
        $Rj = 8 * strlen($YP) - 8 + $uZ;
        $Qq = chr((1 << ($Rj & 0x7)) - 1) . str_repeat(chr(0xff), $Rj >> 3);
        goto tE;
        P7:
        $Rj = $this->precision;
        if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
            goto J_;
        }
        $Qq = $this->bitmask->toBytes();
        goto gT;
        J_:
        $Qq = $this->bitmask->subtract(new Math_BigInteger(1));
        $Qq = $Qq->toBytes();
        gT:
        tE:
        if (!($tB < 0)) {
            goto L0;
        }
        $tB += $Rj;
        L0:
        $tB %= $Rj;
        if ($tB) {
            goto Pz;
        }
        return $this->copy();
        Pz:
        $v1 = $this->bitwise_leftShift($tB);
        $v1 = $v1->bitwise_and(new Math_BigInteger($Qq, 256));
        $rm = $this->bitwise_rightShift($Rj - $tB);
        $al = MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ? $v1->bitwise_or($rm) : $v1->add($rm);
        return $this->_normalize($al);
    }
    function bitwise_rightRotate($tB)
    {
        return $this->bitwise_leftRotate(-$tB);
    }
    function setRandomGenerator($WH)
    {
    }
    function _random_number_helper($Rp)
    {
        if (function_exists("\143\x72\x79\x70\164\137\x72\141\x6e\144\x6f\155\x5f\163\x74\162\151\x6e\x67")) {
            goto wc;
        }
        $Gm = '';
        if (!($Rp & 1)) {
            goto Pc;
        }
        $Gm .= chr(mt_rand(0, 255));
        Pc:
        $J4 = $Rp >> 1;
        $uZ = 0;
        iR:
        if (!($uZ < $J4)) {
            goto E2;
        }
        $Gm .= pack("\x6e", mt_rand(0, 0xffff));
        Os:
        ++$uZ;
        goto iR;
        E2:
        goto V3;
        wc:
        $Gm = crypt_random_string($Rp);
        V3:
        return new Math_BigInteger($Gm, 256);
    }
    function random($vR, $dF = false)
    {
        if (!($vR === false)) {
            goto XQ;
        }
        return false;
        XQ:
        if ($dF === false) {
            goto Ct;
        }
        $b8 = $vR;
        $nx = $dF;
        goto BH;
        Ct:
        $nx = $vR;
        $b8 = $this;
        BH:
        $Ek = $nx->compare($b8);
        if (!$Ek) {
            goto tt;
        }
        if ($Ek < 0) {
            goto Ni;
        }
        goto jY;
        tt:
        return $this->_normalize($b8);
        goto jY;
        Ni:
        $Ml = $nx;
        $nx = $b8;
        $b8 = $Ml;
        jY:
        static $is;
        if (isset($is)) {
            goto FM;
        }
        $is = new Math_BigInteger(1);
        FM:
        $nx = $nx->subtract($b8->subtract($is));
        $Rp = strlen(ltrim($nx->toBytes(), chr(0)));
        $m8 = new Math_BigInteger(chr(1) . str_repeat("\0", $Rp), 256);
        $Gm = $this->_random_number_helper($Rp);
        list($nv) = $m8->divide($nx);
        $nv = $nv->multiply($nx);
        Lf:
        if (!($Gm->compare($nv) >= 0)) {
            goto RT;
        }
        $Gm = $Gm->subtract($nv);
        $m8 = $m8->subtract($nv);
        $Gm = $Gm->bitwise_leftShift(8);
        $Gm = $Gm->add($this->_random_number_helper(1));
        $m8 = $m8->bitwise_leftShift(8);
        list($nv) = $m8->divide($nx);
        $nv = $nv->multiply($nx);
        goto Lf;
        RT:
        list(, $Gm) = $Gm->divide($nx);
        return $this->_normalize($Gm->add($b8));
    }
    function randomPrime($vR, $dF = false, $Y4 = false)
    {
        if (!($vR === false)) {
            goto wp;
        }
        return false;
        wp:
        if ($dF === false) {
            goto yS;
        }
        $b8 = $vR;
        $nx = $dF;
        goto Vb;
        yS:
        $nx = $vR;
        $b8 = $this;
        Vb:
        $Ek = $nx->compare($b8);
        if (!$Ek) {
            goto qv;
        }
        if ($Ek < 0) {
            goto VT;
        }
        goto qa;
        qv:
        return $b8->isPrime() ? $b8 : false;
        goto qa;
        VT:
        $Ml = $nx;
        $nx = $b8;
        $b8 = $Ml;
        qa:
        static $is, $m2;
        if (isset($is)) {
            goto Ma;
        }
        $is = new Math_BigInteger(1);
        $m2 = new Math_BigInteger(2);
        Ma:
        $zJ = time();
        $Rb = $this->random($b8, $nx);
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP && extension_loaded("\147\155\x70") && version_compare(PHP_VERSION, "\65\56\x32\56\60", "\76\75"))) {
            goto qW;
        }
        $MV = new Math_BigInteger();
        $MV->value = gmp_nextprime($Rb->value);
        if (!($MV->compare($nx) <= 0)) {
            goto G3;
        }
        return $MV;
        G3:
        if ($b8->equals($Rb)) {
            goto gp;
        }
        $Rb = $Rb->subtract($is);
        gp:
        return $Rb->randomPrime($b8, $Rb);
        qW:
        if (!$Rb->equals($m2)) {
            goto iv;
        }
        return $Rb;
        iv:
        $Rb->_make_odd();
        if (!($Rb->compare($nx) > 0)) {
            goto xp;
        }
        if (!$b8->equals($nx)) {
            goto RN;
        }
        return false;
        RN:
        $Rb = $b8->copy();
        $Rb->_make_odd();
        xp:
        $cg = $Rb->copy();
        lm:
        if (!true) {
            goto oA;
        }
        if (!($Y4 !== false && time() - $zJ > $Y4)) {
            goto sI;
        }
        return false;
        sI:
        if (!$Rb->isPrime()) {
            goto sm;
        }
        return $Rb;
        sm:
        $Rb = $Rb->add($m2);
        if (!($Rb->compare($nx) > 0)) {
            goto fr;
        }
        $Rb = $b8->copy();
        if (!$Rb->equals($m2)) {
            goto Jz;
        }
        return $Rb;
        Jz:
        $Rb->_make_odd();
        fr:
        if (!$Rb->equals($cg)) {
            goto xE;
        }
        return false;
        xE:
        goto lm;
        oA:
    }
    function _make_odd()
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                gmp_setbit($this->value, 0);
                goto fz;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value[strlen($this->value) - 1] % 2 == 0)) {
                    goto MU;
                }
                $this->value = bcadd($this->value, "\x31");
                MU:
                goto fz;
            default:
                $this->value[0] |= 1;
        }
        qF:
        fz:
    }
    function isPrime($I0 = false)
    {
        $iI = strlen($this->toBytes());
        if ($I0) {
            goto r8;
        }
        if ($iI >= 163) {
            goto oN;
        }
        if ($iI >= 106) {
            goto zU;
        }
        if ($iI >= 81) {
            goto XX;
        }
        if ($iI >= 68) {
            goto XW;
        }
        if ($iI >= 56) {
            goto dP;
        }
        if ($iI >= 50) {
            goto Ox;
        }
        if ($iI >= 43) {
            goto DW;
        }
        if ($iI >= 37) {
            goto WB;
        }
        if ($iI >= 31) {
            goto dZ;
        }
        if ($iI >= 25) {
            goto EU;
        }
        if ($iI >= 18) {
            goto bY;
        }
        $I0 = 27;
        goto tp;
        bY:
        $I0 = 18;
        tp:
        goto sN;
        EU:
        $I0 = 15;
        sN:
        goto IM;
        dZ:
        $I0 = 12;
        IM:
        goto N_;
        WB:
        $I0 = 9;
        N_:
        goto HZ;
        DW:
        $I0 = 8;
        HZ:
        goto aC;
        Ox:
        $I0 = 7;
        aC:
        goto j8;
        dP:
        $I0 = 6;
        j8:
        goto m2;
        XW:
        $I0 = 5;
        m2:
        goto zs;
        XX:
        $I0 = 4;
        zs:
        goto Sq;
        zU:
        $I0 = 3;
        Sq:
        goto SV;
        oN:
        $I0 = 2;
        SV:
        r8:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_prob_prime($this->value, $I0) != 0;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\62")) {
                    goto sX;
                }
                return true;
                sX:
                if (!($this->value[strlen($this->value) - 1] % 2 == 0)) {
                    goto iJ;
                }
                return false;
                iJ:
                goto Gz;
            default:
                if (!($this->value == array(2))) {
                    goto eu;
                }
                return true;
                eu:
                if (!(~$this->value[0] & 1)) {
                    goto Qs;
                }
                return false;
                Qs:
        }
        Jw:
        Gz:
        static $Ds, $Zy, $is, $m2;
        if (isset($Ds)) {
            goto p2;
        }
        $Ds = array(3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997);
        if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL)) {
            goto ea;
        }
        $uZ = 0;
        Ek:
        if (!($uZ < count($Ds))) {
            goto Uf;
        }
        $Ds[$uZ] = new Math_BigInteger($Ds[$uZ]);
        Yr:
        ++$uZ;
        goto Ek;
        Uf:
        ea:
        $Zy = new Math_BigInteger();
        $is = new Math_BigInteger(1);
        $m2 = new Math_BigInteger(2);
        p2:
        if (!$this->equals($is)) {
            goto AI;
        }
        return false;
        AI:
        if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
            goto re;
        }
        $pj = $this->value;
        foreach ($Ds as $VJ) {
            list(, $g5) = $this->_divide_digit($pj, $VJ);
            if ($g5) {
                goto df;
            }
            return count($pj) == 1 && $pj[0] == $VJ;
            df:
            qm:
        }
        EF:
        goto sB;
        re:
        foreach ($Ds as $VJ) {
            list(, $g5) = $this->divide($VJ);
            if (!$g5->equals($Zy)) {
                goto Le;
            }
            return $this->equals($VJ);
            Le:
            dQ:
        }
        IB:
        sB:
        $xJ = $this->copy();
        $YI = $xJ->subtract($is);
        $j4 = $xJ->subtract($m2);
        $g5 = $YI->copy();
        $UM = $g5->value;
        if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
            goto UU;
        }
        $uZ = 0;
        $ii = count($UM);
        Vi:
        if (!($uZ < $ii)) {
            goto ge;
        }
        $Ml = ~$UM[$uZ] & 0xffffff;
        $qP = 1;
        yP:
        if (!($Ml >> $qP & 1)) {
            goto nb;
        }
        wg:
        ++$qP;
        goto yP;
        nb:
        if (!($qP != 25)) {
            goto n0;
        }
        goto ge;
        n0:
        HJ:
        ++$uZ;
        goto Vi;
        ge:
        $rM = 26 * $uZ + $qP;
        $g5->_rshift($rM);
        goto Ar;
        UU:
        $rM = 0;
        Oh:
        if (!($g5->value[strlen($g5->value) - 1] % 2 == 0)) {
            goto gs;
        }
        $g5->value = bcdiv($g5->value, "\62", 0);
        ++$rM;
        goto Oh;
        gs:
        Ar:
        $uZ = 0;
        TO:
        if (!($uZ < $I0)) {
            goto xS;
        }
        $OZ = $this->random($m2, $j4);
        $vN = $OZ->modPow($g5, $xJ);
        if (!(!$vN->equals($is) && !$vN->equals($YI))) {
            goto GL;
        }
        $qP = 1;
        fy:
        if (!($qP < $rM && !$vN->equals($YI))) {
            goto hB;
        }
        $vN = $vN->modPow($m2, $xJ);
        if (!$vN->equals($is)) {
            goto g5;
        }
        return false;
        g5:
        wZ:
        ++$qP;
        goto fy;
        hB:
        if ($vN->equals($YI)) {
            goto ab;
        }
        return false;
        ab:
        GL:
        Fh:
        ++$uZ;
        goto TO;
        xS:
        return true;
    }
    function _lshift($tB)
    {
        if (!($tB == 0)) {
            goto it;
        }
        return;
        it:
        $ax = (int) ($tB / MATH_BIGINTEGER_BASE);
        $tB %= MATH_BIGINTEGER_BASE;
        $tB = 1 << $tB;
        $x9 = 0;
        $uZ = 0;
        Xc:
        if (!($uZ < count($this->value))) {
            goto MR;
        }
        $Ml = $this->value[$uZ] * $tB + $x9;
        $x9 = MATH_BIGINTEGER_BASE === 26 ? intval($Ml / 0x4000000) : $Ml >> 31;
        $this->value[$uZ] = (int) ($Ml - $x9 * MATH_BIGINTEGER_BASE_FULL);
        d8:
        ++$uZ;
        goto Xc;
        MR:
        if (!$x9) {
            goto K3;
        }
        $this->value[count($this->value)] = $x9;
        K3:
        Wn:
        if (!$ax--) {
            goto ij;
        }
        array_unshift($this->value, 0);
        goto Wn;
        ij:
    }
    function _rshift($tB)
    {
        if (!($tB == 0)) {
            goto mJ;
        }
        return;
        mJ:
        $ax = (int) ($tB / MATH_BIGINTEGER_BASE);
        $tB %= MATH_BIGINTEGER_BASE;
        $Ex = MATH_BIGINTEGER_BASE - $tB;
        $Ax = (1 << $tB) - 1;
        if (!$ax) {
            goto oU;
        }
        $this->value = array_slice($this->value, $ax);
        oU:
        $x9 = 0;
        $uZ = count($this->value) - 1;
        Hy:
        if (!($uZ >= 0)) {
            goto Hz;
        }
        $Ml = $this->value[$uZ] >> $tB | $x9;
        $x9 = ($this->value[$uZ] & $Ax) << $Ex;
        $this->value[$uZ] = $Ml;
        Qa:
        --$uZ;
        goto Hy;
        Hz:
        $this->value = $this->_trim($this->value);
    }
    function _normalize($al)
    {
        $al->precision = $this->precision;
        $al->bitmask = $this->bitmask;
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (!($this->bitmask !== false)) {
                    goto XH;
                }
                $al->value = gmp_and($al->value, $al->bitmask->value);
                XH:
                return $al;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (empty($al->bitmask->value)) {
                    goto ao;
                }
                $al->value = bcmod($al->value, $al->bitmask->value);
                ao:
                return $al;
        }
        xm:
        y1:
        $pj =& $al->value;
        if (count($pj)) {
            goto m8;
        }
        return $al;
        m8:
        $pj = $this->_trim($pj);
        if (empty($al->bitmask->value)) {
            goto r_;
        }
        $iI = min(count($pj), count($this->bitmask->value));
        $pj = array_slice($pj, 0, $iI);
        $uZ = 0;
        Y_:
        if (!($uZ < $iI)) {
            goto SA;
        }
        $pj[$uZ] = $pj[$uZ] & $this->bitmask->value[$uZ];
        sC:
        ++$uZ;
        goto Y_;
        SA:
        r_:
        return $al;
    }
    function _trim($pj)
    {
        $uZ = count($pj) - 1;
        A3:
        if (!($uZ >= 0)) {
            goto mH;
        }
        if (!$pj[$uZ]) {
            goto uI;
        }
        goto mH;
        uI:
        unset($pj[$uZ]);
        Dk:
        --$uZ;
        goto A3;
        mH:
        return $pj;
    }
    function _array_repeat($Xd, $BO)
    {
        return $BO ? array_fill(0, $BO, $Xd) : array();
    }
    function _base256_lshift(&$Rb, $tB)
    {
        if (!($tB == 0)) {
            goto lR;
        }
        return;
        lR:
        $io = $tB >> 3;
        $tB &= 7;
        $x9 = 0;
        $uZ = strlen($Rb) - 1;
        YN:
        if (!($uZ >= 0)) {
            goto dN;
        }
        $Ml = ord($Rb[$uZ]) << $tB | $x9;
        $Rb[$uZ] = chr($Ml);
        $x9 = $Ml >> 8;
        u6:
        --$uZ;
        goto YN;
        dN:
        $x9 = $x9 != 0 ? chr($x9) : '';
        $Rb = $x9 . $Rb . str_repeat(chr(0), $io);
    }
    function _base256_rshift(&$Rb, $tB)
    {
        if (!($tB == 0)) {
            goto u0;
        }
        $Rb = ltrim($Rb, chr(0));
        return '';
        u0:
        $io = $tB >> 3;
        $tB &= 7;
        $OV = '';
        if (!$io) {
            goto D6;
        }
        $zJ = $io > strlen($Rb) ? -strlen($Rb) : -$io;
        $OV = substr($Rb, $zJ);
        $Rb = substr($Rb, 0, -$io);
        D6:
        $x9 = 0;
        $Ex = 8 - $tB;
        $uZ = 0;
        f8:
        if (!($uZ < strlen($Rb))) {
            goto tN;
        }
        $Ml = ord($Rb[$uZ]) >> $tB | $x9;
        $x9 = ord($Rb[$uZ]) << $Ex & 0xff;
        $Rb[$uZ] = chr($Ml);
        qu:
        ++$uZ;
        goto f8;
        tN:
        $Rb = ltrim($Rb, chr(0));
        $OV = chr($x9 >> $Ex) . $OV;
        return ltrim($OV, chr(0));
    }
    function _int2bytes($Rb)
    {
        return ltrim(pack("\x4e", $Rb), chr(0));
    }
    function _bytes2int($Rb)
    {
        $Ml = unpack("\116\151\156\164", str_pad($Rb, 4, chr(0), STR_PAD_LEFT));
        return $Ml["\x69\x6e\x74"];
    }
    function _encodeASN1Length($iI)
    {
        if (!($iI <= 0x7f)) {
            goto Q4;
        }
        return chr($iI);
        Q4:
        $Ml = ltrim(pack("\x4e", $iI), chr(0));
        return pack("\103\x61\x2a", 0x80 | strlen($Ml), $Ml);
    }
    function _safe_divide($Rb, $vN)
    {
        if (!(MATH_BIGINTEGER_BASE === 26)) {
            goto CK;
        }
        return (int) ($Rb / $vN);
        CK:
        return ($Rb - $Rb % $vN) / $vN;
    }
}
